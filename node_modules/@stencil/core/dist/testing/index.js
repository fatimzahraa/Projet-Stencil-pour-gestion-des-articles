'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var fs = require('fs');
var fs__default = _interopDefault(fs);
var mockDoc = require('../mock-doc');
var ts = require('typescript');
var crypto = _interopDefault(require('crypto'));
var cp = require('child_process');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function startPuppeteerBrowser(config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config.flags.e2e) {
            return null;
        }
        const env = process.env;
        const puppeteerModulePath = config.sys.lazyRequire.getModulePath('puppeteer');
        const puppeteer = require(puppeteerModulePath);
        env.__STENCIL_PUPPETEER_MODULE__ = puppeteerModulePath;
        config.logger.debug(`puppeteer: ${puppeteerModulePath}`);
        config.logger.debug(`puppeteer headless: ${config.testing.browserHeadless}`);
        if (Array.isArray(config.testing.browserArgs)) {
            config.logger.debug(`puppeteer args: ${config.testing.browserArgs.join(' ')}`);
        }
        if (typeof config.testing.browserSlowMo === 'number') {
            config.logger.debug(`puppeteer slowMo: ${config.testing.browserSlowMo}`);
        }
        const launchOpts = {
            ignoreHTTPSErrors: true,
            args: config.testing.browserArgs,
            headless: config.testing.browserHeadless,
            slowMo: config.testing.browserSlowMo
        };
        if (config.testing.browserExecutablePath) {
            launchOpts.executablePath = config.testing.browserExecutablePath;
        }
        const browser = yield puppeteer.launch(launchOpts);
        env.__STENCIL_BROWSER_WS_ENDPOINT__ = browser.wsEndpoint();
        config.logger.debug(`puppeteer browser wsEndpoint: ${env.__STENCIL_BROWSER_WS_ENDPOINT__}`);
        return browser;
    });
}
function connectBrowser() {
    return __awaiter(this, void 0, void 0, function* () {
        // the reason we're connecting to the browser from
        // a web socket is because jest probably has us
        // in a different thread, this is also why this
        // uses process.env for data
        const env = process.env;
        const wsEndpoint = env.__STENCIL_BROWSER_WS_ENDPOINT__;
        if (!wsEndpoint) {
            return null;
        }
        const connectOpts = {
            browserWSEndpoint: wsEndpoint,
            ignoreHTTPSErrors: true
        };
        const puppeteer = require(env.__STENCIL_PUPPETEER_MODULE__);
        return yield puppeteer.connect(connectOpts);
    });
}
function disconnectBrowser(browser, pages) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(pages)) {
            yield Promise.all(pages.map(closePage));
        }
        if (browser) {
            try {
                browser.disconnect();
            }
            catch (e) { }
        }
    });
}
function newBrowserPage(browser) {
    return browser.newPage();
}
function closePage(page) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(page._elements)) {
            const disposes = page._elements.map((elmHande) => __awaiter(this, void 0, void 0, function* () {
                if (typeof elmHande.e2eDispose === 'function') {
                    yield elmHande.e2eDispose();
                }
            }));
            yield Promise.all(disposes);
        }
        try {
            if (!page.isClosed()) {
                yield page.close();
            }
        }
        catch (e) { }
    });
}

function createJestPuppeteerEnvironment() {
    const jestEnvNodeModulePath = process.env.__STENCIL_JEST_ENVIRONMENT_NODE_MODULE__ || 'jest-environment-node';
    const NodeEnvironment = require(jestEnvNodeModulePath);
    const JestEnvironment = class extends NodeEnvironment {
        constructor(config) {
            super(config);
            this.browser = null;
            this.pages = [];
        }
        setup() {
            return __awaiter(this, void 0, void 0, function* () {
                if (process.env.__STENCIL_E2E_TESTS__ === 'true') {
                    this.global.__NEW_TEST_PAGE__ = this.newPuppeteerPage.bind(this);
                }
            });
        }
        newPuppeteerPage() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.browser) {
                    // load the browser and page on demand
                    this.browser = yield connectBrowser();
                }
                if (!this.browser) {
                    return null;
                }
                const page = yield newBrowserPage(this.browser);
                this.pages.push(page);
                return page;
            });
        }
        teardown() {
            const _super = name => super[name];
            return __awaiter(this, void 0, void 0, function* () {
                yield _super("teardown").call(this);
                yield disconnectBrowser(this.browser, this.pages);
                this.pages.length = 0;
                this.browser = null;
            });
        }
    };
    return JestEnvironment;
}

/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const stack = [];
function h(nodeName, vnodeData) {
    let children = null;
    let lastSimple = false;
    let simple = false;
    for (var i = arguments.length; i-- > 2;) {
        stack.push(arguments[i]);
    }
    while (stack.length > 0) {
        let child = stack.pop();
        if (child && child.pop !== undefined) {
            for (i = child.length; i--;) {
                stack.push(child[i]);
            }
        }
        else {
            if (typeof child === 'boolean') {
                child = null;
            }
            if ((simple = typeof nodeName !== 'function')) {
                if (child == null) {
                    child = '';
                }
                else if (typeof child === 'number') {
                    child = String(child);
                }
                else if (typeof child !== 'string') {
                    simple = false;
                }
            }
            if (simple && lastSimple) {
                children[children.length - 1].vtext += child;
            }
            else if (children === null) {
                children = [simple ? { vtext: child } : child];
            }
            else {
                children.push(simple ? { vtext: child } : child);
            }
            lastSimple = simple;
        }
    }
    let vkey;
    let vname;
    if (vnodeData != null) {
        // normalize class / classname attributes
        if (vnodeData['className']) {
            vnodeData['class'] = vnodeData['className'];
        }
        if (typeof vnodeData['class'] === 'object') {
            for (i in vnodeData['class']) {
                if (vnodeData['class'][i]) {
                    stack.push(i);
                }
            }
            vnodeData['class'] = stack.join(' ');
            stack.length = 0;
        }
        if (vnodeData.key != null) {
            vkey = vnodeData.key;
        }
        if (vnodeData.name != null) {
            vname = vnodeData.name;
        }
    }
    if (typeof nodeName === 'function') {
        // nodeName is a functional component
        return nodeName(vnodeData, children || [], utils);
    }
    return {
        vtag: nodeName,
        vchildren: children,
        vtext: undefined,
        vattrs: vnodeData,
        vkey: vkey,
        vname: vname,
        elm: undefined,
        ishost: false
    };
}
function childToVNode(child) {
    return {
        vtag: child['vtag'],
        vchildren: child['vchildren'],
        vtext: child['vtext'],
        vattrs: child['vattrs'],
        vkey: child['vkey'],
        vname: child['vname']
    };
}
function VNodeToChild(vnode) {
    return {
        'vtag': vnode.vtag,
        'vchildren': vnode.vchildren,
        'vtext': vnode.vtext,
        'vattrs': vnode.vattrs,
        'vkey': vnode.vkey,
        'vname': vnode.vname
    };
}
const utils = {
    'forEach': (children, cb) => {
        children.forEach((item, index, array) => cb(VNodeToChild(item), index, array));
    },
    'map': (children, cb) => {
        return children.map((item, index, array) => childToVNode(cb(VNodeToChild(item), index, array)));
    }
};

function cleanDiagnostics(diagnostics) {
    const cleaned = [];
    const maxErrors = Math.min(diagnostics.length, MAX_ERRORS);
    const dups = new Set();
    for (var i = 0; i < maxErrors; i++) {
        const d = diagnostics[i];
        const key = d.absFilePath + d.code + d.messageText + d.type;
        if (dups.has(key)) {
            continue;
        }
        dups.add(key);
        if (d.messageText) {
            if (typeof d.messageText.message === 'string') {
                d.messageText = d.messageText.message;
            }
            else if (typeof d.messageText === 'string' && d.messageText.indexOf('Error: ') === 0) {
                d.messageText = d.messageText.substr(7);
            }
        }
        cleaned.push(d);
    }
    return cleaned;
}
function splitLineBreaks(sourceText) {
    if (!sourceText)
        return [];
    sourceText = sourceText.replace(/\\r/g, '\n');
    return sourceText.split('\n');
}
const MAX_ERRORS = 15;

/**
 * SSR Attribute Names
 */
/**
 * Default style mode id
 */
const DEFAULT_STYLE_MODE = '$';

function buildError(diagnostics) {
    const diagnostic = {
        level: 'error',
        type: 'build',
        header: 'Build Error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(diagnostic);
    return diagnostic;
}
function buildWarn(diagnostics) {
    const diagnostic = {
        level: 'warn',
        type: 'build',
        header: 'build warn',
        messageText: 'build warn',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    diagnostics.push(diagnostic);
    return diagnostic;
}
function catchError(diagnostics, err, msg) {
    const diagnostic = {
        level: 'error',
        type: 'build',
        header: 'Build Error',
        messageText: 'build error',
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (typeof msg === 'string') {
        diagnostic.messageText = msg;
    }
    else if (err) {
        if (err.stack) {
            diagnostic.messageText = err.stack.toString();
        }
        else {
            if (err.message) {
                diagnostic.messageText = err.message.toString();
            }
            else {
                diagnostic.messageText = err.toString();
            }
        }
    }
    if (diagnostics && !shouldIgnoreError(diagnostic.messageText)) {
        diagnostics.push(diagnostic);
    }
}
const TASK_CANCELED_MSG = `task canceled`;
function shouldIgnoreError(msg) {
    return (msg === TASK_CANCELED_MSG);
}
function hasError(diagnostics) {
    if (!diagnostics) {
        return false;
    }
    return diagnostics.some(d => d.level === 'error' && d.type !== 'runtime');
}
function hasWarning(diagnostics) {
    if (!diagnostics) {
        return false;
    }
    return diagnostics.some(d => d.level === 'warn');
}
function pathJoin(config, ...paths) {
    return normalizePath(config.sys.path.join.apply(config.sys.path, paths));
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, '/');
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === '/') {
        const colonIndex = str.indexOf(':');
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

function generateHmr(config, compilerCtx, buildCtx) {
    if (!config.devServer || !config.devServer.hotReplacement || !buildCtx.isRebuild) {
        return null;
    }
    const hmr = {};
    if (buildCtx.scriptsAdded.length > 0) {
        hmr.scriptsAdded = buildCtx.scriptsAdded.slice();
    }
    if (buildCtx.scriptsDeleted.length > 0) {
        hmr.scriptsDeleted = buildCtx.scriptsDeleted.slice();
    }
    const excludeHmr = excludeHmrFiles(config, config.devServer.excludeHmr, buildCtx.filesChanged);
    if (excludeHmr.length > 0) {
        hmr.excludeHmr = excludeHmr.slice();
    }
    if (buildCtx.hasIndexHtmlChanges) {
        hmr.indexHtmlUpdated = true;
    }
    if (buildCtx.hasServiceWorkerChanges) {
        hmr.serviceWorkerUpdated = true;
    }
    const componentsUpdated = getComponentsUpdated(compilerCtx, buildCtx);
    if (componentsUpdated) {
        hmr.componentsUpdated = componentsUpdated;
    }
    if (Object.keys(buildCtx.stylesUpdated).length > 0) {
        hmr.inlineStylesUpdated = buildCtx.stylesUpdated.map(s => {
            return {
                styleTag: s.styleTag,
                styleMode: s.styleMode,
                styleText: s.styleText,
                isScoped: s.isScoped
            };
        }).sort((a, b) => {
            if (a.styleTag < b.styleTag)
                return -1;
            if (a.styleTag > b.styleTag)
                return 1;
            return 0;
        });
    }
    const externalStylesUpdated = getExternalStylesUpdated(config, buildCtx);
    if (externalStylesUpdated) {
        hmr.externalStylesUpdated = externalStylesUpdated;
    }
    const externalImagesUpdated = getImagesUpdated(config, buildCtx);
    if (externalImagesUpdated) {
        hmr.imagesUpdated = externalImagesUpdated;
    }
    if (Object.keys(hmr).length === 0) {
        return null;
    }
    hmr.versionId = Date.now().toString().substring(6);
    return hmr;
}
function getComponentsUpdated(compilerCtx, buildCtx) {
    // find all of the components that would be affected from the file changes
    if (!buildCtx.filesChanged) {
        return null;
    }
    const filesToLookForImporters = buildCtx.filesChanged.filter(f => {
        return f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js') || f.endsWith('.jsx');
    });
    if (filesToLookForImporters.length === 0) {
        return null;
    }
    const changedScriptFiles = [];
    const checkedFiles = [];
    const allModuleFiles = Object.keys(compilerCtx.moduleFiles)
        .map(tsFilePath => compilerCtx.moduleFiles[tsFilePath])
        .filter(moduleFile => moduleFile.localImports && moduleFile.localImports.length > 0);
    while (filesToLookForImporters.length > 0) {
        const scriptFile = filesToLookForImporters.shift();
        addTsFileImporters(allModuleFiles, filesToLookForImporters, checkedFiles, changedScriptFiles, scriptFile);
    }
    const tags = changedScriptFiles.reduce((tags, changedTsFile) => {
        const moduleFile = compilerCtx.moduleFiles[changedTsFile];
        if (moduleFile && moduleFile.cmpMeta && moduleFile.cmpMeta.tagNameMeta) {
            if (!tags.includes(moduleFile.cmpMeta.tagNameMeta)) {
                tags.push(moduleFile.cmpMeta.tagNameMeta);
            }
        }
        return tags;
    }, []);
    if (tags.length === 0) {
        return null;
    }
    return tags.sort();
}
function addTsFileImporters(allModuleFiles, filesToLookForImporters, checkedFiles, changedScriptFiles, scriptFile) {
    if (!changedScriptFiles.includes(scriptFile)) {
        // add it to our list of files to transpile
        changedScriptFiles.push(scriptFile);
    }
    if (checkedFiles.includes(scriptFile)) {
        // already checked this file
        return;
    }
    checkedFiles.push(scriptFile);
    // get all the ts files that import this ts file
    const tsFilesThatImportsThisTsFile = allModuleFiles.reduce((arr, moduleFile) => {
        moduleFile.localImports.forEach(localImport => {
            let checkFile = localImport;
            if (checkFile === scriptFile) {
                arr.push(moduleFile.sourceFilePath);
                return;
            }
            checkFile = localImport + '.tsx';
            if (checkFile === scriptFile) {
                arr.push(moduleFile.sourceFilePath);
                return;
            }
            checkFile = localImport + '.ts';
            if (checkFile === scriptFile) {
                arr.push(moduleFile.sourceFilePath);
                return;
            }
            checkFile = localImport + '.js';
            if (checkFile === scriptFile) {
                arr.push(moduleFile.sourceFilePath);
                return;
            }
        });
        return arr;
    }, []);
    // add all the files that import this ts file to the list of ts files we need to look through
    tsFilesThatImportsThisTsFile.forEach(tsFileThatImportsThisTsFile => {
        // if we add to this array, then the while look will keep working until it's empty
        filesToLookForImporters.push(tsFileThatImportsThisTsFile);
    });
}
function getExternalStylesUpdated(config, buildCtx) {
    if (!buildCtx.isRebuild) {
        return null;
    }
    const outputTargets = config.outputTargets.filter(o => o.type === 'www');
    if (outputTargets.length === 0) {
        return null;
    }
    const cssFiles = buildCtx.filesWritten.filter(f => f.endsWith('.css'));
    if (cssFiles.length === 0) {
        return null;
    }
    return cssFiles.map(cssFile => {
        return config.sys.path.basename(cssFile);
    }).sort();
}
function getImagesUpdated(config, buildCtx) {
    const outputTargets = config.outputTargets.filter(o => o.type === 'www');
    if (outputTargets.length === 0) {
        return null;
    }
    const imageFiles = buildCtx.filesChanged.reduce((arr, filePath) => {
        if (IMAGE_EXT.some(ext => filePath.toLowerCase().endsWith(ext))) {
            const fileName = config.sys.path.basename(filePath);
            if (!arr.includes(fileName)) {
                arr.push(fileName);
            }
        }
        return arr;
    }, []);
    if (imageFiles.length === 0) {
        return null;
    }
    return imageFiles.sort();
}
function excludeHmrFiles(config, excludeHmr, filesChanged) {
    const excludeFiles = [];
    if (!excludeHmr || excludeHmr.length === 0) {
        return excludeFiles;
    }
    excludeHmr.forEach(excludeHmr => {
        return filesChanged.map(fileChanged => {
            let shouldExclude = false;
            if (config.sys.isGlob(excludeHmr)) {
                shouldExclude = config.sys.minimatch(fileChanged, excludeHmr);
            }
            else {
                shouldExclude = (normalizePath(excludeHmr) === normalizePath(fileChanged));
            }
            if (shouldExclude) {
                config.logger.debug(`excludeHmr: ${fileChanged}`);
                excludeFiles.push(config.sys.path.basename(fileChanged));
            }
            return shouldExclude;
        }).some(r => r);
    });
    return excludeFiles.sort();
}
const IMAGE_EXT = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.svg'];

function generateBuildResults(config, compilerCtx, buildCtx) {
    const timeSpan = buildCtx.createTimeSpan(`generateBuildResults started`, true);
    const buildResults = {
        buildId: buildCtx.buildId,
        bundleBuildCount: buildCtx.bundleBuildCount,
        diagnostics: cleanDiagnostics(buildCtx.diagnostics),
        dirsAdded: buildCtx.dirsAdded.slice().sort(),
        dirsDeleted: buildCtx.dirsDeleted.slice().sort(),
        duration: Date.now() - buildCtx.startTime,
        filesAdded: buildCtx.filesAdded.slice().sort(),
        filesChanged: buildCtx.filesChanged.slice().sort(),
        filesDeleted: buildCtx.filesDeleted.slice().sort(),
        filesUpdated: buildCtx.filesUpdated.slice().sort(),
        filesWritten: buildCtx.filesWritten.sort(),
        hasError: hasError(buildCtx.diagnostics),
        hasSlot: buildCtx.hasSlot,
        hasSuccessfulBuild: compilerCtx.hasSuccessfulBuild,
        hasSvg: buildCtx.hasSvg,
        isRebuild: buildCtx.isRebuild,
        styleBuildCount: buildCtx.styleBuildCount,
        transpileBuildCount: buildCtx.transpileBuildCount,
        components: [],
        entries: generateBuildResultsEntries(config, buildCtx)
    };
    const hmr = generateHmr(config, compilerCtx, buildCtx);
    if (hmr) {
        buildResults.hmr = hmr;
    }
    buildResults.entries.forEach(en => {
        buildResults.components.push(...en.components);
    });
    timeSpan.finish(`generateBuildResults finished`);
    return buildResults;
}
function generateBuildResultsEntries(config, buildCtx) {
    const entries = buildCtx.entryModules.map(en => {
        return getEntryModule(config, buildCtx, en);
    });
    return entries;
}
function getEntryModule(config, buildCtx, en) {
    en.modeNames = en.modeNames || [];
    en.entryBundles = en.entryBundles || [];
    en.moduleFiles = en.moduleFiles || [];
    const entryCmps = [];
    buildCtx.entryPoints.forEach(ep => {
        entryCmps.push(...ep);
    });
    const buildEntry = getBuildEntry(config, entryCmps, en);
    const modes = en.modeNames.slice();
    if (modes.length > 1 || (modes.length === 1 && modes[0] !== DEFAULT_STYLE_MODE)) {
        buildEntry.modes = modes.sort();
    }
    en.moduleFiles.forEach(m => {
        const encap = m.cmpMeta.encapsulationMeta === 2 /* ScopedCss */ ? 'scoped' : m.cmpMeta.encapsulationMeta === 1 /* ShadowDom */ ? 'shadow' : 'none';
        if (!buildEntry.encapsulations.includes(encap)) {
            buildEntry.encapsulations.push(encap);
        }
    });
    buildEntry.encapsulations.sort();
    return buildEntry;
}
function getBuildEntry(config, entryCmps, en) {
    const buildEntry = {
        entryId: en.entryKey,
        components: en.moduleFiles.map(m => {
            const entryCmp = entryCmps.find(ec => {
                return ec.tag === m.cmpMeta.tagNameMeta;
            });
            const dependencyOf = ((entryCmp && entryCmp.dependencyOf) || []).slice().sort();
            const buildCmp = {
                tag: m.cmpMeta.tagNameMeta,
                dependencies: m.cmpMeta.dependencies.slice(),
                dependencyOf: dependencyOf
            };
            return buildCmp;
        }),
        bundles: en.entryBundles.map(entryBundle => {
            return getBuildBundle(config, entryBundle);
        }),
        inputs: en.moduleFiles.map(m => {
            return normalizePath(config.sys.path.relative(config.rootDir, m.jsFilePath));
        }).sort(),
        encapsulations: []
    };
    return buildEntry;
}
function getBuildBundle(config, entryBundle) {
    const buildBundle = {
        fileName: entryBundle.fileName,
        outputs: entryBundle.outputs.map(filePath => {
            return normalizePath(config.sys.path.relative(config.rootDir, filePath));
        }).sort()
    };
    buildBundle.size = entryBundle.text.length;
    if (typeof entryBundle.sourceTarget === 'string') {
        buildBundle.target = entryBundle.sourceTarget;
    }
    if (entryBundle.modeName !== DEFAULT_STYLE_MODE) {
        buildBundle.mode = entryBundle.modeName;
    }
    if (entryBundle.isScopedStyles) {
        buildBundle.scopedStyles = entryBundle.isScopedStyles;
    }
    return buildBundle;
}

function generateBuildStats(config, compilerCtx, buildCtx, buildResults) {
    return __awaiter(this, void 0, void 0, function* () {
        const statsTargets = config.outputTargets.filter(o => o.type === 'stats');
        yield Promise.all(statsTargets.map((outputTarget) => __awaiter(this, void 0, void 0, function* () {
            yield generateStatsOutputTarget(config, compilerCtx, buildCtx, buildResults, outputTarget);
        })));
    });
}
function generateStatsOutputTarget(config, compilerCtx, buildCtx, buildResults, outputTarget) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let jsonData;
            if (buildResults.hasError) {
                jsonData = {
                    diagnostics: buildResults.diagnostics
                };
            }
            else {
                const stats = {
                    compiler: {
                        name: config.sys.compiler.name,
                        version: config.sys.compiler.version
                    },
                    app: {
                        namespace: config.namespace,
                        fsNamespace: config.fsNamespace,
                        components: buildResults.components.length,
                        entries: buildResults.entries.length,
                        bundles: buildResults.entries.reduce((total, en) => {
                            total += en.bundles.length;
                            return total;
                        }, 0)
                    },
                    options: {
                        minifyJs: config.minifyJs,
                        minifyCss: config.minifyCss,
                        hashFileNames: config.hashFileNames,
                        hashedFileNameLength: config.hashedFileNameLength,
                        buildEs5: config.buildEs5
                    },
                    components: buildResults.components,
                    entries: buildResults.entries,
                    rollupResults: buildCtx.rollupResults,
                    sourceGraph: {},
                    collections: buildCtx.collections.map(c => {
                        return {
                            name: c.collectionName,
                            source: normalizePath(config.sys.path.relative(config.rootDir, c.moduleDir)),
                            tags: c.moduleFiles.map(m => m.cmpMeta.tagNameMeta).sort()
                        };
                    }).sort((a, b) => {
                        if (a.name < b.name)
                            return -1;
                        if (a.name > b.name)
                            return 1;
                        return 0;
                    })
                };
                const moduleFiles = compilerCtx.rootTsFiles.map(rootTsFile => {
                    return compilerCtx.moduleFiles[rootTsFile];
                });
                moduleFiles
                    .sort((a, b) => {
                    if (a.sourceFilePath < b.sourceFilePath)
                        return -1;
                    if (a.sourceFilePath > b.sourceFilePath)
                        return 1;
                    return 0;
                }).forEach(moduleFile => {
                    const key = normalizePath(config.sys.path.relative(config.rootDir, moduleFile.sourceFilePath));
                    stats.sourceGraph[key] = moduleFile.localImports.map(localImport => {
                        return normalizePath(config.sys.path.relative(config.rootDir, localImport));
                    }).sort();
                });
                jsonData = stats;
            }
            yield compilerCtx.fs.writeFile(outputTarget.file, JSON.stringify(jsonData, null, 2));
            yield compilerCtx.fs.commit();
        }
        catch (e) { }
    });
}

function getRegistryFileName(config) {
    return `${config.fsNamespace}.registry.json`;
}
function getLoaderFileName(config) {
    return `${config.fsNamespace}.js`;
}
function getLoaderPath(config, outputTarget) {
    return pathJoin(config, outputTarget.buildDir, getLoaderFileName(config));
}
function getGlobalFileName(config) {
    return `${config.fsNamespace}.global.js`;
}
const GENERATED_DTS = 'components.d.ts';

class FsWatchNormalizer {
    constructor(config, events) {
        this.config = config;
        this.events = events;
        this.dirsAdded = [];
        this.dirsDeleted = [];
        this.filesAdded = [];
        this.filesDeleted = [];
        this.filesUpdated = [];
    }
    fileUpdate(filePath) {
        filePath = normalizePath(filePath);
        if (shouldIgnore(filePath)) {
            return;
        }
        if (!this.filesUpdated.includes(filePath)) {
            this.log('file updated', filePath);
            this.filesUpdated.push(filePath);
            this.queue();
        }
    }
    fileAdd(filePath) {
        filePath = normalizePath(filePath);
        if (shouldIgnore(filePath)) {
            return;
        }
        if (!this.filesAdded.includes(filePath)) {
            this.log('file added', filePath);
            this.filesAdded.push(filePath);
            this.queue();
        }
    }
    fileDelete(filePath) {
        filePath = normalizePath(filePath);
        if (shouldIgnore(filePath)) {
            return;
        }
        if (!this.filesDeleted.includes(filePath)) {
            this.log('file deleted', filePath);
            this.filesDeleted.push(filePath);
            this.queue();
        }
    }
    dirAdd(dirPath) {
        dirPath = normalizePath(dirPath);
        if (!this.dirsAdded.includes(dirPath)) {
            this.log('directory added', dirPath);
            this.dirsAdded.push(dirPath);
            this.queue();
        }
    }
    dirDelete(dirPath) {
        dirPath = normalizePath(dirPath);
        if (!this.dirsDeleted.includes(dirPath)) {
            this.log('directory deleted', dirPath);
            this.dirsDeleted.push(dirPath);
            this.queue();
        }
    }
    queue() {
        // let's chill out for a few moments to see if anything else
        // comes in as something that changed in the file system
        clearTimeout(this.flushTmrId);
        this.flushTmrId = setTimeout(this.flush.bind(this), 40);
    }
    flush() {
        // create the watch results from all that we've learned today
        const fsWatchResults = {
            dirsAdded: this.dirsAdded.slice(),
            dirsDeleted: this.dirsDeleted.slice(),
            filesAdded: this.filesAdded.slice(),
            filesDeleted: this.filesDeleted.slice(),
            filesUpdated: this.filesUpdated.slice()
        };
        // reset the data for next time
        this.dirsAdded.length = 0;
        this.dirsDeleted.length = 0;
        this.filesAdded.length = 0;
        this.filesDeleted.length = 0;
        this.filesUpdated.length = 0;
        // send out the event of what we've learend
        this.events.emit('fsChange', fsWatchResults);
    }
    subscribe() {
        this.events.subscribe('fileUpdate', this.fileUpdate.bind(this));
        this.events.subscribe('fileAdd', this.fileAdd.bind(this));
        this.events.subscribe('fileDelete', this.fileDelete.bind(this));
        this.events.subscribe('dirAdd', this.dirAdd.bind(this));
        this.events.subscribe('dirDelete', this.dirDelete.bind(this));
    }
    log(msg, filePath) {
        const relPath = this.config.sys.path.relative(this.config.rootDir, filePath);
        this.config.logger.debug(`watch, ${msg}: ${relPath}, ${Date.now().toString().substring(5)}`);
    }
}
function shouldIgnore(filePath) {
    return filePath.endsWith(GENERATED_DTS);
}

function initFsWatch(config, compilerCtx, buildCtx) {
    // only create the watcher if this is a watch build
    // and we haven't created a watch listener already
    if (compilerCtx.hasWatch || !config.watch) {
        return false;
    }
    buildCtx.debug(`initFsWatch: ${config.sys.path.relative(config.rootDir, config.srcDir)}`);
    const fsWatchNormalizer = new FsWatchNormalizer(config, compilerCtx.events);
    fsWatchNormalizer.subscribe();
    compilerCtx.hasWatch = true;
    if (config.sys.createFsWatcher) {
        const fsWatcher = config.sys.createFsWatcher(compilerCtx.events, config.srcDir, {
            ignored: config.watchIgnoredRegex,
            ignoreInitial: true
        });
        if (fsWatcher && config.configPath) {
            config.configPath = normalizePath(config.configPath);
            fsWatcher.add(config.configPath);
        }
    }
    return true;
}

function writeCacheStats(config, compilerCtx, buildCtx) {
    if (!config.enableCacheStats) {
        return;
    }
    const statsPath = pathJoin(config, config.rootDir, 'stencil-cache-stats.json');
    config.logger.warn(`cache stats enabled for debugging, which is horrible for build times. Only enableCacheStats when debugging memory issues.`);
    const timeSpan = config.logger.createTimeSpan(`cache stats started: ${statsPath}`);
    let statsData = {};
    try {
        const dataStr = compilerCtx.fs.disk.readFileSync(statsPath);
        statsData = JSON.parse(dataStr);
    }
    catch (e) { }
    statsData['compilerCtx'] = statsData['compilerCtx'] || {};
    getObjectSize(statsData['compilerCtx'], compilerCtx);
    statsData['compilerCtx.cache.cacheFs.items'] = statsData['compilerCtx.cache.cacheFs.items'] || {};
    getObjectSize(statsData['compilerCtx.cache.cacheFs.items'], compilerCtx.cache['cacheFs']['items']);
    statsData['buildCtx'] = statsData['buildCtx'] || {};
    getObjectSize(statsData['buildCtx'], buildCtx);
    compilerCtx.fs.disk.writeFileSync(statsPath, JSON.stringify(statsData, null, 2));
    timeSpan.finish(`cache stats finished`);
}
function getObjectSize(data, obj) {
    if (obj) {
        Object.keys(obj).forEach(key => {
            if (typeof obj[key] === 'object') {
                const size = objectSizeEstimate(obj[key]);
                if (size > 20000) {
                    data[key] = data[key] || [];
                    data[key].push(size);
                }
            }
        });
    }
}
function objectSizeEstimate(obj) {
    if (!obj) {
        return 0;
    }
    const objectList = [];
    const stack = [obj];
    let bytes = 0;
    while (stack.length) {
        const value = stack.pop();
        if (typeof value === 'boolean') {
            bytes += 4;
        }
        else if (typeof value === 'string') {
            bytes += value.length * 2;
        }
        else if (typeof value === 'number') {
            bytes += 8;
        }
        else if (typeof value === 'object' && !objectList.includes(value)) {
            objectList.push(value);
            for (const i in value) {
                stack.push(value[i]);
            }
        }
    }
    return bytes;
}

function buildFinish(config, compilerCtx, buildCtx, aborted) {
    return __awaiter(this, void 0, void 0, function* () {
        if (buildCtx.hasFinished && buildCtx.buildResults) {
            // we've already marked this build as finished and
            // already created the build results, just return these
            return buildCtx.buildResults;
        }
        buildCtx.debug(`${aborted ? 'aborted' : 'finished'} build, ${buildCtx.timestamp}`);
        // create the build results data
        buildCtx.buildResults = generateBuildResults(config, compilerCtx, buildCtx);
        // log any errors/warnings
        if (!buildCtx.hasFinished) {
            // haven't set this build as finished yet
            if (!buildCtx.hasPrintedResults) {
                config.logger.printDiagnostics(buildCtx.buildResults.diagnostics);
            }
            if (!compilerCtx.hasLoggedServerUrl && config.devServer && config.devServer.browserUrl && config.flags.serve) {
                // we've opened up the dev server
                // let's print out the dev server url
                config.logger.info(`dev server: ${config.logger.cyan(config.devServer.browserUrl)}`);
                compilerCtx.hasLoggedServerUrl = true;
            }
            if (buildCtx.isRebuild && buildCtx.buildResults.hmr && !aborted && buildCtx.isActiveBuild) {
                // this is a rebuild, and we've got hmr data
                // and this build hasn't been aborted
                logHmr(config, buildCtx);
            }
            // create a nice pretty message stating what happend
            const buildText = buildCtx.isRebuild ? 'rebuild' : 'build';
            const watchText = config.watch ? ', watching for changes...' : '';
            let buildStatus = 'finished';
            let statusColor = 'green';
            if (buildCtx.hasError) {
                // gosh darn, build had errors
                // ಥ_ಥ
                compilerCtx.lastBuildHadError = true;
                buildStatus = 'failed';
                statusColor = 'red';
            }
            else {
                // successful build!
                // ┏(°.°)┛ ┗(°.°)┓ ┗(°.°)┛ ┏(°.°)┓
                compilerCtx.hasSuccessfulBuild = true;
                compilerCtx.lastBuildHadError = false;
            }
            if (!aborted) {
                // print out the time it took to build
                // and add the duration to the build results
                buildCtx.timeSpan.finish(`${buildText} ${buildStatus}${watchText}`, statusColor, true, true);
                buildCtx.hasPrintedResults = true;
                // write the build stats
                yield generateBuildStats(config, compilerCtx, buildCtx, buildCtx.buildResults);
                // emit a buildFinish event for anyone who cares
                compilerCtx.events.emit('buildFinish', buildCtx.buildResults);
            }
            // write all of our logs to disk if config'd to do so
            // do this even if there are errors or not the active build
            config.logger.writeLogs(buildCtx.isRebuild);
            if (config.watch) {
                // this is a watch build
                // setup watch if we haven't done so already
                initFsWatch(config, compilerCtx, buildCtx);
            }
            else {
                // not a watch build, so lets destroy anything left open
                config.sys.destroy();
            }
        }
        // write cache stats only for memory debugging
        writeCacheStats(config, compilerCtx, buildCtx);
        // it's official, this build has finished
        buildCtx.hasFinished = true;
        if (buildCtx.isActiveBuild) {
            compilerCtx.isActivelyBuilding = false;
        }
        return buildCtx.buildResults;
    });
}
function logHmr(config, buildCtx) {
    // this is a rebuild, and we've got hmr data
    // and this build hasn't been aborted
    const hmr = buildCtx.buildResults.hmr;
    if (hmr.componentsUpdated) {
        cleanupUpdateMsg(config, `updated component`, hmr.componentsUpdated);
    }
    if (hmr.inlineStylesUpdated) {
        const inlineStyles = hmr.inlineStylesUpdated.map(s => s.styleTag).reduce((arr, v) => {
            if (!arr.includes(v)) {
                arr.push(v);
            }
            return arr;
        }, []);
        cleanupUpdateMsg(config, `updated style`, inlineStyles);
    }
    if (hmr.externalStylesUpdated) {
        cleanupUpdateMsg(config, `updated stylesheet`, hmr.externalStylesUpdated);
    }
    if (hmr.imagesUpdated) {
        cleanupUpdateMsg(config, `updated image`, hmr.imagesUpdated);
    }
}
function cleanupUpdateMsg(config, msg, fileNames) {
    if (fileNames.length > 0) {
        let fileMsg = '';
        if (fileNames.length > 7) {
            const remaining = fileNames.length - 6;
            fileNames = fileNames.slice(0, 6);
            fileMsg = fileNames.join(', ') + `, +${remaining} others`;
        }
        else {
            fileMsg = fileNames.join(', ');
        }
        if (fileNames.length > 1) {
            msg += 's';
        }
        config.logger.info(`${msg}: ${config.logger.cyan(fileMsg)}`);
    }
}

class BuildContext {
    constructor(config, compilerCtx) {
        this.config = config;
        this.compilerCtx = compilerCtx;
        this.appFileBuildCount = 0;
        this.buildId = -1;
        this.buildMessages = [];
        this.buildResults = null;
        this.bundleBuildCount = 0;
        this.collections = [];
        this.components = [];
        this.data = {};
        this.diagnostics = [];
        this.dirsAdded = [];
        this.dirsDeleted = [];
        this.entryModules = [];
        this.entryPoints = [];
        this.filesAdded = [];
        this.filesChanged = [];
        this.filesDeleted = [];
        this.filesUpdated = [];
        this.filesWritten = [];
        this.global = null;
        this.graphData = null;
        this.hasConfigChanges = false;
        this.hasCopyChanges = false;
        this.hasFinished = false;
        this.hasIndexHtmlChanges = false;
        this.hasPrintedResults = false;
        this.hasServiceWorkerChanges = false;
        this.hasScriptChanges = true;
        this.hasSlot = null;
        this.hasStyleChanges = true;
        this.hasSvg = null;
        this.indexBuildCount = 0;
        this.isRebuild = false;
        this.requiresFullBuild = true;
        this.scriptsAdded = [];
        this.scriptsDeleted = [];
        this.startTime = Date.now();
        this.styleBuildCount = 0;
        this.stylesUpdated = [];
        this.timeSpan = null;
        this.transpileBuildCount = 0;
    }
    start() {
        this.compilerCtx.isActivelyBuilding = true;
        // get the build id from the incremented activeBuildId
        ++this.compilerCtx.activeBuildId;
        if (this.compilerCtx.activeBuildId >= 100) {
            // reset the build id back to 0
            this.compilerCtx.activeBuildId = 0;
        }
        this.buildId = this.compilerCtx.activeBuildId;
        // print out a good message
        const msg = `${this.isRebuild ? 'rebuild' : 'build'}, ${this.config.fsNamespace}, ${this.config.devMode ? 'dev' : 'prod'} mode, started`;
        // create a timespan for this build
        this.timeSpan = this.createTimeSpan(msg);
        // create a build timestamp for this build
        this.timestamp = getBuildTimestamp();
        // debug log our new build
        this.debug(`start build, ${this.timestamp}`);
    }
    createTimeSpan(msg, debug) {
        if ((this.isActiveBuild && !this.hasFinished) || debug) {
            if (debug) {
                if (this.config.watch) {
                    msg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`;
                }
            }
            const timeSpan = this.config.logger.createTimeSpan(msg, debug, this.buildMessages);
            if (!debug && this.compilerCtx.events) {
                this.compilerCtx.events.emit('buildLog', {
                    messages: this.buildMessages.slice()
                });
            }
            return {
                finish: (finishedMsg, color, bold, newLineSuffix) => {
                    if ((this.isActiveBuild && !this.hasFinished) || debug) {
                        if (debug) {
                            if (this.config.watch) {
                                finishedMsg = `${this.config.logger.cyan('[' + this.buildId + ']')} ${finishedMsg}`;
                            }
                        }
                        timeSpan.finish(finishedMsg, color, bold, newLineSuffix);
                        if (!debug) {
                            this.compilerCtx.events.emit('buildLog', {
                                messages: this.buildMessages.slice()
                            });
                        }
                    }
                }
            };
        }
        return {
            finish: () => { }
        };
    }
    debug(msg) {
        if (this.config.watch) {
            this.config.logger.debug(`${this.config.logger.cyan('[' + this.buildId + ']')} ${msg}`);
        }
        else {
            this.config.logger.debug(msg);
        }
    }
    get isActiveBuild() {
        return (this.compilerCtx.activeBuildId === this.buildId);
    }
    get hasError() {
        if (hasError(this.diagnostics)) {
            // remember if the last build had an error or not
            // this is useful if the next build should do a full build or not
            this.compilerCtx.lastBuildHadError = true;
            return true;
        }
        return false;
    }
    get hasWarning() {
        if (hasWarning(this.diagnostics)) {
            return true;
        }
        return false;
    }
    abort() {
        return __awaiter(this, void 0, void 0, function* () {
            return buildFinish(this.config, this.compilerCtx, this, true);
        });
    }
    finish() {
        return __awaiter(this, void 0, void 0, function* () {
            return buildFinish(this.config, this.compilerCtx, this, false);
        });
    }
    validateTypesBuild() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasError || !this.isActiveBuild) {
                // no need to wait on this one since
                // we already aborted this build
                return;
            }
            if (!this.validateTypesPromise) {
                // there is no pending validate types promise
                // so it probably already finished
                // so no need to wait on anything
                return;
            }
            if (!this.config.watch) {
                // this is not a watch build, so we need to make
                // sure that the type validation has finished
                this.debug(`build, non-watch, waiting on validateTypes`);
                yield this.validateTypesPromise;
                this.debug(`build, non-watch, finished waiting on validateTypes`);
            }
        });
    }
}
function getBuildTimestamp() {
    const d = new Date();
    // YYYY-MM-DDThh:mm:ss
    let timestamp = d.getUTCFullYear() + '-';
    timestamp += ('0' + d.getUTCMonth()).slice(-2) + '-';
    timestamp += ('0' + d.getUTCDate()).slice(-2) + 'T';
    timestamp += ('0' + d.getUTCHours()).slice(-2) + ':';
    timestamp += ('0' + d.getUTCMinutes()).slice(-2) + ':';
    timestamp += ('0' + d.getUTCSeconds()).slice(-2);
    return timestamp;
}

const toLowerCase = (str) => str.toLowerCase();
const toDashCase = (str) => toLowerCase(str.replace(/([A-Z0-9])/g, g => ' ' + g[0]).trim().replace(/ /g, '-'));
const dashToPascalCase = (str) => toLowerCase(str).split('-').map(segment => segment.charAt(0).toUpperCase() + segment.slice(1)).join('');
const noop = () => { };
const pluck = (obj, keys) => {
    return keys.reduce((final, key) => {
        if (obj[key]) {
            final[key] = obj[key];
        }
        return final;
    }, {});
};
const isObject = (val) => {
    return val != null && typeof val === 'object' && Array.isArray(val) === false;
};

class TestingFs {
    constructor() {
        this.data = {};
        this.diskWrites = 0;
        this.diskReads = 0;
    }
    copyFile(srcPath, destPath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                this.diskReads++;
                if (!this.data[srcPath]) {
                    reject(`copyFile, srcPath doesn't exists: ${srcPath}`);
                }
                else {
                    this.diskWrites++;
                    this.data[destPath] = this.data[srcPath];
                    resolve();
                }
            }, this.resolveTime);
        });
    }
    createReadStream(_filePath) {
        return {};
    }
    mkdir(dirPath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                dirPath = normalizePath(dirPath);
                this.diskWrites++;
                if (this.data[dirPath]) {
                    reject(`mkdir, dir already exists: ${dirPath}`);
                }
                else {
                    this.data[dirPath] = {
                        isDirectory: true,
                        isFile: false
                    };
                    resolve();
                }
            }, this.resolveTime);
        });
    }
    mkdirSync(dirPath) {
        dirPath = normalizePath(dirPath);
        this.diskWrites++;
        if (this.data[dirPath]) {
            throw new Error(`mkdir, dir already exists: ${dirPath}`);
        }
        else {
            this.data[dirPath] = {
                isDirectory: true,
                isFile: false
            };
        }
    }
    readdir(dirPath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    const dirs = this.readdirSync(dirPath);
                    resolve(dirs.sort());
                }
                catch (e) {
                    reject(e);
                }
            }, this.resolveTime);
        });
    }
    readdirSync(dirPath) {
        dirPath = normalizePath(dirPath);
        this.diskReads++;
        if (!this.data[dirPath]) {
            throw new Error(`readdir, dir doesn't exists: ${dirPath}`);
        }
        const filePaths = Object.keys(this.data);
        const dirs = [];
        filePaths.forEach(f => {
            const pathRelative = path.relative(dirPath, f);
            // Windows: pathRelative =  ..\dir2\dir3\dir4\file2.js
            const dirItem = normalizePath(pathRelative).split('/')[0];
            if (!dirItem.startsWith('.') && !dirItem.startsWith('/')) {
                if (dirItem !== '' && !dirs.includes(dirItem)) {
                    dirs.push(dirItem);
                }
            }
        });
        return dirs;
    }
    readFile(filePath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    resolve(this.readFileSync(filePath));
                }
                catch (e) {
                    reject(e);
                }
            }, this.resolveTime);
        });
    }
    readFileSync(filePath) {
        filePath = normalizePath(filePath);
        this.diskReads++;
        if (this.data[filePath] && typeof this.data[filePath].content === 'string') {
            return this.data[filePath].content;
        }
        throw new Error(`readFile, path doesn't exist: ${filePath}`);
    }
    rmdir(dirPath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                dirPath = normalizePath(dirPath);
                if (!this.data[dirPath]) {
                    reject(`rmdir, dir doesn't exists: ${dirPath}`);
                }
                else {
                    Object.keys(this.data).forEach(item => {
                        if (item.startsWith(dirPath + '/') || item === dirPath) {
                            this.diskWrites++;
                            delete this.data[item];
                        }
                    });
                    resolve();
                }
            }, this.resolveTime);
        });
    }
    stat(itemPath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    resolve(this.statSync(itemPath));
                }
                catch (e) {
                    reject(e);
                }
            }, this.resolveTime);
        });
    }
    statSync(itemPath) {
        itemPath = normalizePath(itemPath);
        this.diskReads++;
        if (this.data[itemPath]) {
            const isDirectory = this.data[itemPath].isDirectory;
            const isFile = this.data[itemPath].isFile;
            return {
                isDirectory: () => isDirectory,
                isFile: () => isFile,
                size: this.data[itemPath].content ? this.data[itemPath].content.length : 0
            };
        }
        throw new Error(`stat, path doesn't exist: ${itemPath}`);
    }
    unlink(filePath) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                filePath = normalizePath(filePath);
                this.diskWrites++;
                if (!this.data[filePath]) {
                    reject(`unlink, file doesn't exists: ${filePath}`);
                }
                else {
                    delete this.data[filePath];
                    resolve();
                }
            }, this.resolveTime);
        });
    }
    writeFile(filePath, content) {
        filePath = normalizePath(filePath);
        return new Promise(resolve => {
            setTimeout(() => {
                this.diskWrites++;
                this.data[filePath] = {
                    isDirectory: false,
                    isFile: true,
                    content: content
                };
                resolve();
            }, this.resolveTime);
        });
    }
    writeFileSync(filePath, content) {
        filePath = normalizePath(filePath);
        this.diskWrites++;
        this.data[filePath] = {
            isDirectory: false,
            isFile: true,
            content: content
        };
    }
    writeFiles(files) {
        return Promise.all(Object.keys(files).map(filePath => {
            return this.writeFile(filePath, files[filePath]);
        }));
    }
    get resolveTime() {
        return (Math.random() * 6);
    }
}

const relDistPath = path.join(__dirname, '..', '..', 'dist');
const nodeSys = require('../sys/node/index');
const NodeSystem = nodeSys.NodeSystem;
class TestingSystem extends NodeSystem {
    constructor() {
        const fs$$1 = new TestingFs();
        super(fs$$1);
        this.createFsWatcher = null;
        this.initWorkers(1, 1);
    }
    get compiler() {
        const compiler = super.compiler;
        compiler.name = 'test';
        compiler.version += '-test';
        return compiler;
    }
    getClientCoreFile(opts) {
        const filePath = path.join(relDistPath, 'client', opts.staticName);
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    tmpdir() {
        return path.join(path.resolve('/'), 'tmp', 'testing');
    }
}

function setBooleanConfig(config, configName, flagName, defaultValue) {
    if (flagName) {
        if (typeof config.flags[flagName] === 'boolean') {
            config[configName] = config.flags[flagName];
        }
    }
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = !!config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'boolean') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setNumberConfig(config, configName, _flagName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'number') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setStringConfig(config, configName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (typeof config[userConfigName] === 'string') {
        config[configName] = config[userConfigName];
    }
    else {
        config[configName] = defaultValue;
    }
}
function setArrayConfig(config, configName, defaultValue) {
    const userConfigName = getUserConfigName(config, configName);
    if (typeof config[userConfigName] === 'function') {
        config[userConfigName] = config[userConfigName]();
    }
    if (!Array.isArray(config[configName])) {
        if (Array.isArray(defaultValue)) {
            config[configName] = defaultValue.slice();
        }
        else {
            config[configName] = [];
        }
    }
}
function getUserConfigName(config, correctConfigName) {
    const userConfigNames = Object.keys(config);
    for (const userConfigName of userConfigNames) {
        if (userConfigName.toLowerCase() === correctConfigName.toLowerCase()) {
            if (userConfigName !== correctConfigName) {
                config.logger.warn(`config "${userConfigName}" should be "${correctConfigName}"`);
                return userConfigName;
            }
            break;
        }
    }
    return correctConfigName;
}

function validateAssetVerioning(config) {
    if (!config.assetVersioning) {
        config.assetVersioning = null;
        return;
    }
    if ((config.assetVersioning) === true) {
        config.assetVersioning = {};
    }
    const hashLength = config.hashedFileNameLength > 3 ? config.hashedFileNameLength : DEFAULTS.hashLength;
    setArrayConfig(config.assetVersioning, 'cssProperties', DEFAULTS.cssProperties);
    setNumberConfig(config.assetVersioning, 'hashLength', null, hashLength);
    setBooleanConfig(config.assetVersioning, 'queryMode', null, DEFAULTS.queryMode);
    setStringConfig(config.assetVersioning, 'prefix', DEFAULTS.separator);
    setStringConfig(config.assetVersioning, 'separator', DEFAULTS.separator);
    setBooleanConfig(config.assetVersioning, 'versionHtml', null, DEFAULTS.versionHtml);
    setBooleanConfig(config.assetVersioning, 'versionManifest', null, DEFAULTS.versionManifest);
    setBooleanConfig(config.assetVersioning, 'versionCssProperties', null, DEFAULTS.versionCssProperties);
}
const DEFAULTS = {
    cssProperties: ['background', 'background-url', 'url'],
    hashLength: 8,
    queryMode: false,
    pattern: '**/*.{css,js,png,jpg,jpeg,gif,svg,json,woff,woff2,ttf,eot}',
    prefix: '',
    separator: '.',
    versionHtml: true,
    versionManifest: true,
    versionCssProperties: true,
};

function validateCopy(config) {
    if (config.copy === null || config.copy === false) {
        // manually forcing to skip the copy task
        config.copy = null;
        return;
    }
    if (!Array.isArray(config.copy)) {
        config.copy = [];
    }
    if (!config.copy.some(c => c.src === DEFAULT_ASSETS.src)) {
        config.copy.push(DEFAULT_ASSETS);
    }
    if (!config.copy.some(c => c.src === DEFAULT_MANIFEST.src)) {
        config.copy.push(DEFAULT_MANIFEST);
    }
}
const DEFAULT_ASSETS = { src: 'assets', warn: false };
const DEFAULT_MANIFEST = { src: 'manifest.json', warn: false };

function validateDevServer(config) {
    config.devServer = config.devServer || {};
    if (typeof config.flags.address === 'string') {
        config.devServer.address = config.flags.address;
    }
    else {
        setStringConfig(config.devServer, 'address', '0.0.0.0');
    }
    if (typeof config.flags.port === 'number') {
        config.devServer.port = config.flags.port;
    }
    else {
        setNumberConfig(config.devServer, 'port', null, 3333);
    }
    setBooleanConfig(config.devServer, 'gzip', null, true);
    setBooleanConfig(config.devServer, 'hotReplacement', null, true);
    setBooleanConfig(config.devServer, 'openBrowser', null, true);
    validateProtocol(config.devServer);
    if (config.devServer.historyApiFallback !== null && config.devServer.historyApiFallback !== false) {
        config.devServer.historyApiFallback = config.devServer.historyApiFallback || {};
        if (typeof config.devServer.historyApiFallback.index !== 'string') {
            config.devServer.historyApiFallback.index = 'index.html';
        }
        if (typeof config.devServer.historyApiFallback.disableDotRule !== 'boolean') {
            config.devServer.historyApiFallback.disableDotRule = false;
        }
    }
    if (config.flags && config.flags.open === false) {
        config.devServer.openBrowser = false;
    }
    let serveDir = null;
    let baseUrl = null;
    const wwwOutputTarget = config.outputTargets.find(o => o.type === 'www');
    if (wwwOutputTarget) {
        serveDir = wwwOutputTarget.dir;
        baseUrl = wwwOutputTarget.baseUrl;
        config.logger.debug(`dev server www root: ${serveDir}, base url: ${baseUrl}`);
    }
    else {
        serveDir = config.rootDir;
        if (config.flags && config.flags.serve) {
            config.logger.debug(`dev server missing www output target, serving root directory: ${serveDir}`);
        }
    }
    if (typeof baseUrl !== 'string') {
        baseUrl = `/`;
    }
    baseUrl = normalizePath(baseUrl);
    if (!baseUrl.startsWith('/')) {
        baseUrl = '/' + baseUrl;
    }
    if (!baseUrl.endsWith('/')) {
        baseUrl += '/';
    }
    setStringConfig(config.devServer, 'root', serveDir);
    setStringConfig(config.devServer, 'baseUrl', baseUrl);
    if (!config.sys.path.isAbsolute(config.devServer.root)) {
        config.devServer.root = pathJoin(config, config.rootDir, config.devServer.root);
    }
    if (config.devServer.excludeHmr) {
        if (!Array.isArray(config.devServer.excludeHmr)) {
            config.logger.error(`dev server excludeHmr must be an array of glob strings`);
        }
    }
    else {
        config.devServer.excludeHmr = [];
    }
    return config.devServer;
}
function validateProtocol(devServer) {
    if (typeof devServer.protocol === 'string') {
        let protocol = devServer.protocol.trim().toLowerCase();
        protocol = protocol.replace(':', '').replace('/', '');
        devServer.protocol = protocol;
    }
    if (devServer.protocol !== 'http' && devServer.protocol !== 'https') {
        devServer.protocol = 'http';
    }
}

function validateNamespace(config) {
    setStringConfig(config, 'namespace', DEFAULT_NAMESPACE);
    config.namespace = config.namespace.trim();
    const invalidNamespaceChars = config.namespace.replace(/(\w)|(\-)|(\$)/g, '');
    if (invalidNamespaceChars !== '') {
        throw new Error(`Namespace "${config.namespace}" contains invalid characters: ${invalidNamespaceChars}`);
    }
    if (config.namespace.length < 3) {
        throw new Error(`Namespace "${config.namespace}" must be at least 3 characters`);
    }
    if (/^\d+$/.test(config.namespace.charAt(0))) {
        throw new Error(`Namespace "${config.namespace}" cannot have a number for the first character`);
    }
    if (config.namespace.charAt(0) === '-') {
        throw new Error(`Namespace "${config.namespace}" cannot have a dash for the first character`);
    }
    if (config.namespace.charAt(config.namespace.length - 1) === '-') {
        throw new Error(`Namespace "${config.namespace}" cannot have a dash for the last character`);
    }
    // the file system namespace is the one
    // used in filenames and seen in the url
    setStringConfig(config, 'fsNamespace', config.namespace.toLowerCase());
    if (config.namespace.includes('-')) {
        // convert to PascalCase
        // this is the same namespace that gets put on "window"
        config.namespace = dashToPascalCase(config.namespace);
    }
}
const DEFAULT_NAMESPACE = 'App';

function validateDocs(config) {
    if (config.flags.docs || typeof config.flags.docsJson === 'string') {
        // docs flag
        config.outputTargets = config.outputTargets || [];
        if (!config.outputTargets.some(o => o.type === 'docs')) {
            // didn't provide a docs config, so let's add one
            const outputTarget = {
                type: 'docs'
            };
            if (typeof config.flags.docsJson === 'string') {
                outputTarget.jsonFile = config.flags.docsJson;
            }
            else if (config.flags.docs) {
                outputTarget.readmeDir = config.srcDir;
            }
            config.outputTargets.push(outputTarget);
        }
        const docsOutputs = config.outputTargets.filter(o => o.type === 'docs');
        docsOutputs.forEach(outputTarget => {
            validateDocsOutputTarget(config, outputTarget);
        });
    }
    else {
        if (config.outputTargets) {
            // remove docs if there is no docs flag
            config.outputTargets = config.outputTargets.filter(o => o.type !== 'docs');
        }
    }
}
function validateDocsOutputTarget(config, outputTarget) {
    if (typeof outputTarget.readmeDir === 'string' && !config.sys.path.isAbsolute(outputTarget.readmeDir)) {
        outputTarget.readmeDir = pathJoin(config, config.rootDir, outputTarget.readmeDir);
    }
    if (typeof outputTarget.jsonFile === 'string') {
        outputTarget.jsonFile = pathJoin(config, config.rootDir, outputTarget.jsonFile);
    }
}

function validateOutputTargetAngular(config) {
    const path$$1 = config.sys.path;
    const distOutputTargets = config.outputTargets.filter(o => o.type === 'angular');
    distOutputTargets.forEach(outputTarget => {
        outputTarget.excludeComponents = outputTarget.excludeComponents || [];
        if (!path$$1.isAbsolute(outputTarget.directivesProxyFile)) {
            outputTarget.directivesProxyFile = normalizePath(path$$1.join(config.rootDir, outputTarget.directivesProxyFile));
        }
        if (!path$$1.isAbsolute(outputTarget.directivesArrayFile)) {
            outputTarget.directivesArrayFile = normalizePath(path$$1.join(config.rootDir, outputTarget.directivesArrayFile));
        }
    });
}

function validateOutputTargetDist(config) {
    const path$$1 = config.sys.path;
    const distOutputTargets = config.outputTargets.filter(o => o.type === 'dist');
    distOutputTargets.forEach(outputTarget => {
        if (!outputTarget.dir) {
            outputTarget.dir = DEFAULT_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.dir)) {
            outputTarget.dir = normalizePath(path$$1.join(config.rootDir, outputTarget.dir));
        }
        if (!outputTarget.buildDir) {
            outputTarget.buildDir = DEFAULT_BUILD_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.buildDir)) {
            outputTarget.buildDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.buildDir));
        }
        if (!outputTarget.collectionDir) {
            outputTarget.collectionDir = DEFAULT_COLLECTION_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.collectionDir)) {
            outputTarget.collectionDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.collectionDir));
        }
        if (!outputTarget.esmLoaderPath) {
            outputTarget.esmLoaderPath = DEFAULT_ESM_LOADER_DIR;
        }
        if (!outputTarget.typesDir) {
            outputTarget.typesDir = DEFAULT_TYPES_DIR;
        }
        if (!path$$1.isAbsolute(outputTarget.typesDir)) {
            outputTarget.typesDir = normalizePath(path$$1.join(outputTarget.dir, outputTarget.typesDir));
        }
        if (typeof outputTarget.empty !== 'boolean') {
            outputTarget.empty = DEFAULT_EMPTY_DIR;
        }
        if (typeof outputTarget.appBuild !== 'boolean') {
            outputTarget.appBuild = true;
        }
    });
}
const DEFAULT_DIR = 'dist';
const DEFAULT_BUILD_DIR = '';
const DEFAULT_EMPTY_DIR = true;
const DEFAULT_COLLECTION_DIR = 'collection';
const DEFAULT_TYPES_DIR = 'types';
const DEFAULT_ESM_LOADER_DIR = 'loader';

function validatePrerender(config, outputTarget) {
    let defaults;
    if (config.flags.prerender) {
        // forcing a prerender build
        defaults = FULL_PRERENDER_DEFAULTS;
    }
    else if (config.flags.ssr) {
        // forcing a ssr build
        defaults = SSR_DEFAULTS;
    }
    else {
        // not forcing a prerender build
        if (config.devMode) {
            // not forcing a prerender build
            // but we're in dev mode
            defaults = DEV_MODE_DEFAULTS;
        }
        else {
            // not forcing a prerender build
            // but we're in prod mode
            defaults = PROD_NON_HYDRATE_DEFAULTS;
        }
    }
    setStringConfig(outputTarget, 'baseUrl', defaults.baseUrl);
    setBooleanConfig(outputTarget, 'canonicalLink', null, defaults.canonicalLink);
    setBooleanConfig(outputTarget, 'collapseWhitespace', null, defaults.collapseWhitespace);
    setBooleanConfig(outputTarget, 'hydrateComponents', null, defaults.hydrateComponents);
    setBooleanConfig(outputTarget, 'inlineStyles', null, defaults.inlineStyles);
    setBooleanConfig(outputTarget, 'inlineLoaderScript', null, defaults.inlineLoaderScript);
    setNumberConfig(outputTarget, 'inlineAssetsMaxSize', null, defaults.inlineAssetsMaxSize);
    setBooleanConfig(outputTarget, 'prerenderUrlCrawl', null, defaults.prerenderUrlCrawl);
    setArrayConfig(outputTarget, 'prerenderLocations', defaults.prerenderLocations);
    setBooleanConfig(outputTarget, 'prerenderPathHash', null, defaults.prerenderPathHash);
    setBooleanConfig(outputTarget, 'prerenderPathQuery', null, defaults.prerenderPathQuery);
    setNumberConfig(outputTarget, 'prerenderMaxConcurrent', null, defaults.prerenderMaxConcurrent);
    setBooleanConfig(outputTarget, 'removeUnusedStyles', null, defaults.removeUnusedStyles);
    defaults.baseUrl = normalizePath(defaults.baseUrl);
    if (!outputTarget.baseUrl.startsWith('/')) {
        throw new Error(`baseUrl "${outputTarget.baseUrl}" must start with a slash "/". This represents an absolute path to the root of the domain.`);
    }
    if (!outputTarget.baseUrl.endsWith('/')) {
        outputTarget.baseUrl += '/';
    }
    if (config.flags.prerender && outputTarget.prerenderLocations.length === 0) {
        outputTarget.prerenderLocations.push({
            path: outputTarget.baseUrl
        });
    }
    if (outputTarget.hydrateComponents) {
        config.buildEs5 = true;
    }
}
const FULL_PRERENDER_DEFAULTS = {
    type: 'www',
    baseUrl: '/',
    canonicalLink: true,
    collapseWhitespace: true,
    hydrateComponents: true,
    inlineStyles: true,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 5000,
    prerenderUrlCrawl: true,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 4,
    removeUnusedStyles: true
};
const SSR_DEFAULTS = {
    type: 'www',
    baseUrl: '/',
    canonicalLink: true,
    collapseWhitespace: true,
    hydrateComponents: true,
    inlineStyles: true,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};
const PROD_NON_HYDRATE_DEFAULTS = {
    type: 'www',
    baseUrl: '/',
    canonicalLink: false,
    collapseWhitespace: true,
    hydrateComponents: false,
    inlineStyles: false,
    inlineLoaderScript: true,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};
const DEV_MODE_DEFAULTS = {
    type: 'www',
    baseUrl: '/',
    canonicalLink: false,
    collapseWhitespace: false,
    hydrateComponents: false,
    inlineStyles: false,
    inlineLoaderScript: false,
    inlineAssetsMaxSize: 0,
    prerenderUrlCrawl: false,
    prerenderPathHash: false,
    prerenderPathQuery: false,
    prerenderMaxConcurrent: 0,
    removeUnusedStyles: false
};

function validateOutputTargetWww(config) {
    if (!Array.isArray(config.outputTargets)) {
        config.outputTargets = [
            { type: 'www' }
        ];
    }
    const wwwOutputTargets = config.outputTargets.filter(o => o.type === 'www');
    wwwOutputTargets.forEach(outputTarget => {
        validateOutputTarget(config, outputTarget);
    });
}
function validateOutputTarget(config, outputTarget) {
    const path$$1 = config.sys.path;
    setStringConfig(outputTarget, 'dir', DEFAULT_DIR$1);
    if (!path$$1.isAbsolute(outputTarget.dir)) {
        outputTarget.dir = pathJoin(config, config.rootDir, outputTarget.dir);
    }
    setStringConfig(outputTarget, 'buildDir', DEFAULT_BUILD_DIR$1);
    if (!path$$1.isAbsolute(outputTarget.buildDir)) {
        outputTarget.buildDir = pathJoin(config, outputTarget.dir, outputTarget.buildDir);
    }
    setStringConfig(outputTarget, 'indexHtml', DEFAULT_INDEX_HTML);
    if (!path$$1.isAbsolute(outputTarget.indexHtml)) {
        outputTarget.indexHtml = pathJoin(config, outputTarget.dir, outputTarget.indexHtml);
    }
    setBooleanConfig(outputTarget, 'empty', null, DEFAULT_EMPTY_DIR$1);
    validatePrerender(config, outputTarget);
    if (typeof outputTarget.appBuild !== 'boolean') {
        outputTarget.appBuild = true;
    }
}
const DEFAULT_DIR$1 = 'www';
const DEFAULT_INDEX_HTML = 'index.html';
const DEFAULT_BUILD_DIR$1 = 'build';
const DEFAULT_EMPTY_DIR$1 = true;

function validateResourcesUrl(outputTarget) {
    if (typeof outputTarget.resourcesUrl === 'string') {
        outputTarget.resourcesUrl = normalizePath(outputTarget.resourcesUrl.trim());
        if (outputTarget.resourcesUrl.charAt(outputTarget.resourcesUrl.length - 1) !== '/') {
            // ensure there's a trailing /
            outputTarget.resourcesUrl += '/';
        }
    }
}

const HOST_CONFIG_FILENAME = 'host.config.json';

function validateServiceWorker(config, outputTarget) {
    if (config.devMode && !config.flags.serviceWorker) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (outputTarget.serviceWorker === false || outputTarget.serviceWorker === null) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (!outputTarget.serviceWorker && outputTarget.type !== 'www') {
        outputTarget.serviceWorker = null;
        return;
    }
    if (outputTarget.serviceWorker === true) {
        outputTarget.serviceWorker = {};
    }
    else if (!outputTarget.serviceWorker && config.devMode) {
        outputTarget.serviceWorker = null;
        return;
    }
    if (typeof outputTarget.serviceWorker !== 'object') {
        // what was passed in could have been a boolean
        // in that case let's just turn it into an empty obj so Object.assign doesn't crash
        outputTarget.serviceWorker = {};
    }
    if (!Array.isArray(outputTarget.serviceWorker.globPatterns)) {
        if (typeof outputTarget.serviceWorker.globPatterns === 'string') {
            outputTarget.serviceWorker.globPatterns = [outputTarget.serviceWorker.globPatterns];
        }
        else if (typeof outputTarget.serviceWorker.globPatterns !== 'string') {
            outputTarget.serviceWorker.globPatterns = [DEFAULT_GLOB_PATTERNS];
        }
    }
    if (typeof outputTarget.serviceWorker.globDirectory !== 'string') {
        outputTarget.serviceWorker.globDirectory = outputTarget.dir;
    }
    if (typeof outputTarget.serviceWorker.globIgnores === 'string') {
        outputTarget.serviceWorker.globIgnores = [outputTarget.serviceWorker.globIgnores];
    }
    outputTarget.serviceWorker.globIgnores = outputTarget.serviceWorker.globIgnores || [];
    addGlobIgnores(config, outputTarget.serviceWorker.globIgnores);
    if (!outputTarget.serviceWorker.swDest) {
        outputTarget.serviceWorker.swDest = config.sys.path.join(outputTarget.dir, DEFAULT_FILENAME);
    }
    if (!config.sys.path.isAbsolute(outputTarget.serviceWorker.swDest)) {
        outputTarget.serviceWorker.swDest = config.sys.path.join(outputTarget.dir, outputTarget.serviceWorker.swDest);
    }
}
function addGlobIgnores(config, globIgnores) {
    const appRegistry = `**/${getRegistryFileName(config)}`;
    globIgnores.push(appRegistry);
    const appGlobal = `**/${getGlobalFileName(config)}`;
    globIgnores.push(appGlobal);
    const hostConfigJson = `**/${HOST_CONFIG_FILENAME}`;
    globIgnores.push(hostConfigJson);
}
const DEFAULT_GLOB_PATTERNS = '**/*.{js,css,json,html,ico,png,svg}';
const DEFAULT_FILENAME = 'sw.js';

function validateStats(config) {
    if (config.flags.stats) {
        const hasOutputTarget = config.outputTargets.some(o => o.type === 'stats');
        if (!hasOutputTarget) {
            config.outputTargets.push({
                type: 'stats'
            });
        }
    }
    const outputTargets = config.outputTargets.filter(o => o.type === 'stats');
    outputTargets.forEach(outputTarget => {
        validateStatsOutputTarget(config, outputTarget);
    });
}
function validateStatsOutputTarget(config, outputTarget) {
    if (!outputTarget.file) {
        outputTarget.file = DEFAULT_JSON_FILE_NAME;
    }
    if (!config.sys.path.isAbsolute(outputTarget.file)) {
        outputTarget.file = pathJoin(config, config.rootDir, outputTarget.file);
    }
}
const DEFAULT_JSON_FILE_NAME = 'stencil-stats.json';

/**
 * DEPRECATED "config" generateWWW, wwwDir, emptyWWW, generateDistribution, distDir, emptyDist
 * since 0.7.0, 2018-03-02
 */
function _deprecatedToMultipleTarget(config) {
    const deprecatedConfigs = [];
    if (config.generateWWW !== undefined) {
        deprecatedConfigs.push('generateWWW');
        if (config.generateWWW) {
            config.outputTargets = config.outputTargets || [];
            let o = config.outputTargets.find(o => o.type === 'www');
            if (!o) {
                o = { type: 'www' };
                config.outputTargets.push(o);
            }
        }
        delete config.generateWWW;
    }
    if (config.emptyWWW !== undefined) {
        deprecatedConfigs.push('emptyWWW');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.empty = !!config.emptyWWW;
        delete config.emptyWWW;
    }
    if (config.wwwDir !== undefined) {
        deprecatedConfigs.push('wwwDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.dir = config.wwwDir;
        delete config.wwwDir;
    }
    if (config.buildDir !== undefined) {
        deprecatedConfigs.push('buildDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.buildDir = config.buildDir;
        delete config.buildDir;
    }
    if (config.wwwIndexHtml !== undefined) {
        deprecatedConfigs.push('wwwIndexHtml');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www' };
            config.outputTargets.push(o);
        }
        o.indexHtml = config.wwwIndexHtml;
        delete config.wwwIndexHtml;
    }
    if (config.generateDistribution !== undefined) {
        deprecatedConfigs.push('generateDistribution');
        if (config.generateDistribution) {
            config.outputTargets = config.outputTargets || [];
            let o = config.outputTargets.find(o => o.type === 'dist');
            if (!o) {
                o = { type: 'dist' };
                config.outputTargets.push(o);
            }
        }
        delete config.generateDistribution;
    }
    if (config.distDir !== undefined) {
        deprecatedConfigs.push('distDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.distDir;
        delete config.distDir;
    }
    if (config.emptyDist !== undefined) {
        deprecatedConfigs.push('emptyDist');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.empty = !!config.emptyDist;
        delete config.emptyDist;
    }
    if (config.collectionDir !== undefined) {
        deprecatedConfigs.push('collectionDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.collectionDir;
        delete config.collectionDir;
    }
    if (config.typesDir !== undefined) {
        deprecatedConfigs.push('typesDir');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'dist');
        if (!o) {
            o = { type: 'dist' };
            config.outputTargets.push(o);
        }
        o.dir = config.typesDir;
        delete config.typesDir;
    }
    if (config.publicPath !== undefined) {
        deprecatedConfigs.push('publicPath');
        config.outputTargets = config.outputTargets || [];
        const www = config.outputTargets.find(o => o.type === 'www');
        if (www) {
            www.resourcesUrl = config.publicPath;
        }
        delete config.publicPath;
    }
    if (config.serviceWorker !== undefined) {
        deprecatedConfigs.push('serviceWorker');
        config.outputTargets = config.outputTargets || [];
        let o = config.outputTargets.find(o => o.type === 'www');
        if (!o) {
            o = { type: 'www', serviceWorker: config.serviceWorker };
            config.outputTargets.push(o);
        }
        else {
            o.serviceWorker = config.serviceWorker;
        }
        delete config.serviceWorker;
    }
    if (config.prerender !== undefined) {
        deprecatedConfigs.push('prerender');
        delete config.prerender;
    }
    if (deprecatedConfigs.length > 0) {
        const warningMsg = [
            `As of v0.7.0, the config `,
            deprecatedConfigs.length > 1 ? `properties ` : `property `,
            `"${deprecatedConfigs.join(', ')}" `,
            deprecatedConfigs.length > 1 ? `have ` : `has `,
            `been deprecated in favor of a multiple output target configuration. `,
            `Please use the "outputTargets" config which `,
            `is an array of output targets. `,
            `Note that not having an "outputTarget" config will default `,
            `to have an { type: "www" } output target. `,
            `More information aobut the new format can be found here: https://stenciljs.com/docs/config`
        ];
        config.logger.warn(warningMsg.join(''));
    }
    return deprecatedConfigs;
}

function validateOutputTargets(config) {
    // setup outputTargets from deprecated config properties
    _deprecatedToMultipleTarget(config);
    if (Array.isArray(config.outputTargets)) {
        config.outputTargets.forEach(outputTarget => {
            if (typeof outputTarget.type !== 'string') {
                outputTarget.type = 'www';
            }
            outputTarget.type = outputTarget.type.trim().toLowerCase();
            if (!VALID_TYPES.includes(outputTarget.type)) {
                throw new Error(`invalid outputTarget type "${outputTarget.type}". Valid target types: ${VALID_TYPES.join(', ')}`);
            }
        });
    }
    validateOutputTargetWww(config);
    validateOutputTargetDist(config);
    validateOutputTargetAngular(config);
    validateDocs(config);
    validateStats(config);
    if (!config.outputTargets || config.outputTargets.length === 0) {
        throw new Error(`outputTarget required`);
    }
    config.outputTargets.forEach(outputTarget => {
        validateResourcesUrl(outputTarget);
        validateServiceWorker(config, outputTarget);
    });
}
const VALID_TYPES = ['angular', 'dist', 'docs', 'stats', 'www'];

function validatePaths(config) {
    const path$$1 = config.sys.path;
    if (typeof config.globalScript === 'string' && !path$$1.isAbsolute(config.globalScript)) {
        if (!path$$1.isAbsolute(config.globalScript)) {
            config.globalScript = path$$1.join(config.rootDir, config.globalScript);
        }
        config.globalScript = normalizePath(config.globalScript);
    }
    if (Array.isArray(config.globalStyle)) {
        // DEPRECATED 2018-05-31
        config.logger.warn(`"globalStyle" config no longer accepts an array. Please update to only use a single entry point for a global style css file.`);
        if (config.globalStyle.length > 0) {
            config.globalStyle = config.globalStyle[0];
        }
    }
    if (typeof config.globalStyle === 'string') {
        if (!path$$1.isAbsolute(config.globalStyle)) {
            config.globalStyle = path$$1.join(config.rootDir, config.globalStyle);
        }
        config.globalStyle = normalizePath(config.globalStyle);
    }
    setStringConfig(config, 'srcDir', DEFAULT_SRC_DIR);
    if (!path$$1.isAbsolute(config.srcDir)) {
        config.srcDir = path$$1.join(config.rootDir, config.srcDir);
    }
    config.srcDir = normalizePath(config.srcDir);
    setStringConfig(config, 'cacheDir', DEFAULT_CACHE_DIR);
    if (!path$$1.isAbsolute(config.cacheDir)) {
        config.cacheDir = path$$1.join(config.rootDir, config.cacheDir);
    }
    config.cacheDir = normalizePath(config.cacheDir);
    setStringConfig(config, 'tsconfig', DEFAULT_TSCONFIG);
    if (!path$$1.isAbsolute(config.tsconfig)) {
        config.tsconfig = path$$1.join(config.rootDir, config.tsconfig);
    }
    config.tsconfig = normalizePath(config.tsconfig);
    setStringConfig(config, 'srcIndexHtml', normalizePath(path$$1.join(config.srcDir, DEFAULT_INDEX_HTML$1)));
    if (!path$$1.isAbsolute(config.srcIndexHtml)) {
        config.srcIndexHtml = path$$1.join(config.rootDir, config.srcIndexHtml);
    }
    config.srcIndexHtml = normalizePath(config.srcIndexHtml);
    if (config.writeLog) {
        setStringConfig(config, 'buildLogFilePath', DEFAULT_BUILD_LOG_FILE_NAME);
        if (!path$$1.isAbsolute(config.buildLogFilePath)) {
            config.buildLogFilePath = path$$1.join(config.rootDir, config.buildLogFilePath);
        }
        config.buildLogFilePath = normalizePath(config.buildLogFilePath);
        config.logger.buildLogFilePath = config.buildLogFilePath;
    }
}
const DEFAULT_BUILD_LOG_FILE_NAME = 'stencil-build.log';
const DEFAULT_CACHE_DIR = '.stencil';
const DEFAULT_INDEX_HTML$1 = 'index.html';
const DEFAULT_SRC_DIR = 'src';
const DEFAULT_TSCONFIG = 'tsconfig.json';

function validatePlugins(config) {
    config.plugins = (config.plugins || []).filter(p => !!p);
}

function validateRollupConfig(config) {
    const cleanRollupConfig = getCleanRollupConfig(config.rollupConfig);
    config.rollupConfig = cleanRollupConfig;
}
function getCleanRollupConfig(rollupConfig) {
    let cleanRollupConfig = DEFAULT_ROLLUP_CONFIG;
    if (!rollupConfig || !isObject(rollupConfig)) {
        return cleanRollupConfig;
    }
    if (rollupConfig.inputOptions && isObject(rollupConfig.inputOptions)) {
        cleanRollupConfig = Object.assign({}, cleanRollupConfig, { inputOptions: pluck(rollupConfig.inputOptions, ['context', 'moduleContext']) });
    }
    if (rollupConfig.outputOptions && isObject(rollupConfig.outputOptions)) {
        cleanRollupConfig = Object.assign({}, cleanRollupConfig, { outputOptions: pluck(rollupConfig.outputOptions, ['globals']) });
    }
    return cleanRollupConfig;
}
const DEFAULT_ROLLUP_CONFIG = {
    inputOptions: {},
    outputOptions: {}
};

function validateTesting(config) {
    const testing = config.testing = config.testing || {};
    if (!config.flags || (!config.flags.e2e && !config.flags.spec)) {
        return;
    }
    if (typeof config.flags.headless === 'boolean') {
        testing.browserHeadless = config.flags.headless;
    }
    else if (typeof testing.browserHeadless !== 'boolean') {
        testing.browserHeadless = true;
    }
    if (config.flags.ci) {
        testing.browserArgs = testing.browserArgs || [];
        if (!testing.browserArgs.includes('--no-sandbox')) {
            testing.browserArgs.push('--no-sandbox');
        }
        if (!testing.browserArgs.includes('--disable-setuid-sandbox')) {
            testing.browserArgs.push('--disable-setuid-sandbox');
        }
        testing.browserHeadless = true;
    }
    const path$$1 = config.sys.path;
    if (typeof testing.rootDir === 'string') {
        if (!path$$1.isAbsolute(testing.rootDir)) {
            testing.rootDir = path$$1.join(config.rootDir, testing.rootDir);
        }
    }
    else {
        testing.rootDir = config.rootDir;
    }
    if (config.flags && typeof config.flags.screenshotConnector === 'string') {
        testing.screenshotConnector = config.flags.screenshotConnector;
    }
    if (typeof testing.screenshotConnector === 'string') {
        if (!path$$1.isAbsolute(testing.screenshotConnector)) {
            testing.screenshotConnector = path$$1.join(config.rootDir, testing.screenshotConnector);
        }
    }
    else {
        testing.screenshotConnector = config.sys.path.join(config.sys.compiler.packageDir, 'screenshot', 'screenshot-connector.js');
    }
    if (!Array.isArray(testing.moduleFileExtensions)) {
        testing.moduleFileExtensions = DEFAULT_MODULE_FILE_EXTENSIONS;
    }
    if (!Array.isArray(testing.testPathIgnorePatterns)) {
        testing.testPathIgnorePatterns = DEFAULT_IGNORE_PATTERNS.map(ignorePattern => {
            return config.sys.path.join(testing.rootDir, ignorePattern);
        });
        config.outputTargets.forEach((outputTarget) => {
            if (outputTarget.dir) {
                testing.testPathIgnorePatterns.push(outputTarget.dir);
            }
        });
    }
    if (typeof testing.setupTestFrameworkScriptFile !== 'string') {
        testing.setupTestFrameworkScriptFile = path$$1.join(config.sys.compiler.packageDir, 'testing', 'jest.setuptest.js');
    }
    else if (!path$$1.isAbsolute(testing.setupTestFrameworkScriptFile)) {
        testing.setupTestFrameworkScriptFile = path$$1.join(config.configPath, testing.setupTestFrameworkScriptFile);
    }
    if (typeof testing.testEnvironment !== 'string') {
        testing.testEnvironment = path$$1.join(config.sys.compiler.packageDir, 'testing', 'jest.environment.js');
    }
    else if (!path$$1.isAbsolute(testing.testEnvironment)) {
        testing.testEnvironment = path$$1.join(config.configPath, testing.testEnvironment);
    }
    if (typeof testing.allowableMismatchedPixels === 'number') {
        if (testing.allowableMismatchedPixels < 0) {
            throw new Error(`allowableMismatchedPixels must be a value that is 0 or greater`);
        }
    }
    else {
        testing.allowableMismatchedPixels = DEFAULT_ALLOWABLE_MISMATCHED_PIXELS;
    }
    if (typeof testing.allowableMismatchedRatio === 'number') {
        if (testing.allowableMismatchedRatio < 0 || testing.allowableMismatchedRatio > 1) {
            throw new Error(`allowableMismatchedRatio must be a value ranging from 0 to 1`);
        }
    }
    if (typeof testing.pixelmatchThreshold === 'number') {
        if (testing.pixelmatchThreshold < 0 || testing.pixelmatchThreshold > 1) {
            throw new Error(`pixelmatchThreshold must be a value ranging from 0 to 1`);
        }
    }
    else {
        testing.pixelmatchThreshold = DEFAULT_PIXEL_MATCH_THRESHOLD;
    }
    if (Array.isArray(testing.testMatch)) {
        delete testing.testRegex;
    }
    else if (typeof testing.testRegex === 'string') {
        delete testing.testMatch;
    }
    else {
        const types = [];
        if (config.flags.e2e) {
            types.push('e2e');
        }
        if (config.flags.spec) {
            types.push('spec');
        }
        testing.testMatch = [
            `**/*(*.)+(${types.join('|')}).+(ts)?(x)`
        ];
    }
    testing.transform = testing.transform || {};
    if (typeof testing.transform[DEFAULT_TS_TRANSFORM] !== 'string') {
        testing.transform[DEFAULT_TS_TRANSFORM] = path$$1.join(config.sys.compiler.packageDir, 'testing', 'jest.preprocessor.js');
    }
    else if (!path$$1.isAbsolute(testing.transform[DEFAULT_TS_TRANSFORM])) {
        testing.transform[DEFAULT_TS_TRANSFORM] = path$$1.join(config.configPath, testing.transform[DEFAULT_TS_TRANSFORM]);
    }
}
const DEFAULT_TS_TRANSFORM = '^.+\\.(ts|tsx)$';
const DEFAULT_MODULE_FILE_EXTENSIONS = [
    'ts',
    'tsx',
    'js',
    'json'
];
const DEFAULT_IGNORE_PATTERNS = [
    '.vscode',
    '.stencil',
    'node_modules',
];
const DEFAULT_ALLOWABLE_MISMATCHED_PIXELS = 100;
const DEFAULT_PIXEL_MATCH_THRESHOLD = 0.1;

function validateWorkers(config) {
    let cpus = 1;
    if (config.sys && config.sys.details && typeof config.sys.details.cpus === 'number') {
        cpus = config.sys.details.cpus;
    }
    if (typeof config.maxConcurrentWorkers !== 'number') {
        config.maxConcurrentWorkers = cpus;
    }
    if (config.flags && typeof config.flags.maxWorkers === 'number') {
        config.maxConcurrentWorkers = config.flags.maxWorkers;
    }
    config.maxConcurrentWorkers = Math.max(Math.min(config.maxConcurrentWorkers, cpus), 1);
    if (typeof config.maxConcurrentTasksPerWorker !== 'number') {
        config.maxConcurrentTasksPerWorker = DEFAULT_MAX_TASKS_PER_WORKER;
    }
    config.maxConcurrentTasksPerWorker = Math.max(Math.min(config.maxConcurrentTasksPerWorker, 20), 1);
}
const DEFAULT_MAX_TASKS_PER_WORKER = 2;

/**
 * DEPRECATED "config.collections" since 0.6.0, 2018-02-13
 */
function _deprecatedValidateConfigCollections(config) {
    if (!Array.isArray(config.collections)) {
        return;
    }
    const deprecatedCollections = config.collections;
    if (deprecatedCollections.length > 0) {
        const errorMsg = [
            `As of v0.6.0, "config.collections" has been deprecated in favor of standard ES module imports. `,
            `Instead of listing collections within the stencil config, collections should now be `,
            `imported by the app's root component or module. The benefit of this is to not only simplify `,
            `the config by using a standards approach for imports, but to also automatically import the `,
            `collection's types to improve development. Please remove "config.collections" `,
            `from the "stencil.config.js" file, and add `,
            deprecatedCollections.length === 1 ? `this import ` : `these imports `,
            `to your root component or root module:  `
        ];
        deprecatedCollections.forEach(collection => {
            errorMsg.push(`import '${collection.name}';  `);
        });
        config.logger.error(errorMsg.join(''));
    }
}

function validateConfig(config, setEnvVariables) {
    if (!config) {
        throw new Error(`invalid build config`);
    }
    if (config._isValidated) {
        // don't bother if we've already validated this config
        return config;
    }
    if (!config.logger) {
        throw new Error(`config.logger required`);
    }
    if (!config.rootDir) {
        throw new Error('config.rootDir required');
    }
    if (!config.sys) {
        throw new Error('config.sys required');
    }
    config.flags = config.flags || {};
    if (config.flags.debug) {
        config.logLevel = 'debug';
    }
    else if (config.flags.logLevel) {
        config.logLevel = config.flags.logLevel;
    }
    else if (typeof config.logLevel !== 'string') {
        config.logLevel = 'info';
    }
    config.logger.level = config.logLevel;
    setBooleanConfig(config, 'writeLog', 'log', false);
    setBooleanConfig(config, 'buildAppCore', null, true);
    // default devMode false
    if (config.flags.prod) {
        config.devMode = false;
    }
    else if (config.flags.dev) {
        config.devMode = true;
    }
    else {
        setBooleanConfig(config, 'devMode', null, DEFAULT_DEV_MODE);
    }
    // get a good namespace
    validateNamespace(config);
    // figure out all of the config paths and absolute paths
    validatePaths(config);
    // setup the outputTargets
    validateOutputTargets(config);
    // validate how many workers we can use
    validateWorkers(config);
    // default devInspector to whatever devMode is
    setBooleanConfig(config, 'devInspector', null, config.devMode);
    // default watch false
    setBooleanConfig(config, 'watch', 'watch', false);
    setBooleanConfig(config, 'minifyCss', null, !config.devMode);
    setBooleanConfig(config, 'minifyJs', null, !config.devMode);
    setBooleanConfig(config, 'buildEs5', 'es5', !config.devMode);
    setBooleanConfig(config, 'buildEsm', null, config.buildEs5);
    setBooleanConfig(config, 'buildScoped', null, config.buildEs5);
    if (typeof config.validateTypes !== 'boolean') {
        config.validateTypes = true;
    }
    setBooleanConfig(config, 'hashFileNames', null, !(config.devMode || config.watch));
    setNumberConfig(config, 'hashedFileNameLength', null, DEFAULT_HASHED_FILENAME_LENTH);
    if (config.hashFileNames) {
        if (config.hashedFileNameLength < MIN_HASHED_FILENAME_LENTH) {
            throw new Error(`config.hashedFileNameLength must be at least ${MIN_HASHED_FILENAME_LENTH} characters`);
        }
        if (config.hashedFileNameLength > MAX_HASHED_FILENAME_LENTH) {
            throw new Error(`config.hashedFileNameLength cannot be more than ${MAX_HASHED_FILENAME_LENTH} characters`);
        }
    }
    validateCopy(config);
    validatePlugins(config);
    validateAssetVerioning(config);
    validateDevServer(config);
    if (!config.watchIgnoredRegex) {
        config.watchIgnoredRegex = DEFAULT_WATCH_IGNORED_REGEX;
    }
    setStringConfig(config, 'hydratedCssClass', DEFAULT_HYDRATED_CSS_CLASS);
    setBooleanConfig(config, 'generateDocs', 'docs', false);
    setBooleanConfig(config, 'enableCache', 'cache', true);
    if (!Array.isArray(config.includeSrc)) {
        config.includeSrc = DEFAULT_INCLUDES.map(include => {
            return config.sys.path.join(config.srcDir, include);
        });
    }
    if (!Array.isArray(config.excludeSrc)) {
        config.excludeSrc = DEFAULT_EXCLUDES.slice();
    }
    /**
     * DEPRECATED "config.collections" since 0.6.0, 2018-02-13
     */
    _deprecatedValidateConfigCollections(config);
    setArrayConfig(config, 'plugins');
    setArrayConfig(config, 'bundles');
    // set to true so it doesn't bother going through all this again on rebuilds
    config._isValidated = true;
    if (setEnvVariables !== false) {
        setProcessEnvironment(config);
    }
    validateRollupConfig(config);
    validateTesting(config);
    return config;
}
function setProcessEnvironment(config) {
    process.env.NODE_ENV = config.devMode ? 'development' : 'production';
}
const DEFAULT_DEV_MODE = false;
const DEFAULT_HASHED_FILENAME_LENTH = 8;
const MIN_HASHED_FILENAME_LENTH = 4;
const MAX_HASHED_FILENAME_LENTH = 32;
const DEFAULT_INCLUDES = ['**/*.ts', '**/*.tsx'];
const DEFAULT_EXCLUDES = ['**/*.+(spec|e2e).*'];
const DEFAULT_WATCH_IGNORED_REGEX = /(?:^|[\\\/])(\.(?!\.)[^\\\/]+)$/i;
const DEFAULT_HYDRATED_CSS_CLASS = 'hydrated';

function mockStencilSystem() {
    return new TestingSystem();
}

const DEFAULT_COMPILER_OPTIONS = {
    // to allow jsx to work
    jsx: ts.JsxEmit.React,
    // the factory function to use
    jsxFactory: 'h',
    // transpileModule does not write anything to disk so there is no need
    // to verify that there are no conflicts between input and output paths.
    suppressOutputPathCheck: true,
    // // Clear out other settings that would not be used in transpiling this module
    lib: [
        'lib.dom.d.ts',
        'lib.es5.d.ts',
        'lib.es2015.d.ts',
        'lib.es2016.d.ts',
        'lib.es2017.d.ts'
    ],
    // We are not doing a full typecheck, we are not resolving the whole context,
    // so pass --noResolve to avoid reporting missing file errors.
    // noResolve: true,
    allowSyntheticDefaultImports: true,
    // must always allow decorators
    experimentalDecorators: true,
    // transpile down to es2017
    target: ts.ScriptTarget.ES2017,
    // create esNext modules
    module: ts.ModuleKind.ESNext,
    // resolve using NodeJs style
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    // ensure that we do emit something
    noEmitOnError: false
};

/**
 * Check if class has component decorator
 * @param classNode
 */
function isComponentClass(classNode) {
    if (!Array.isArray(classNode.decorators)) {
        return false;
    }
    const componentDecoratorIndex = classNode.decorators.findIndex(dec => (ts.isCallExpression(dec.expression) && ts.isIdentifier(dec.expression.expression) && dec.expression.expression.text === 'Component'));
    return (componentDecoratorIndex !== -1);
}
/**
 * Convert a js value into typescript AST
 * @param val array, object, string, boolean, or number
 * @returns Typescript Object Literal, Array Literal, String Literal, Boolean Literal, Numeric Literal
 */
function convertValueToLiteral(val) {
    if (val === String) {
        return ts.createIdentifier('String');
    }
    if (val === Number) {
        return ts.createIdentifier('Number');
    }
    if (val === Boolean) {
        return ts.createIdentifier('Boolean');
    }
    if (Array.isArray(val)) {
        return arrayToArrayLiteral(val);
    }
    if (typeof val === 'object') {
        return objectToObjectLiteral(val);
    }
    return ts.createLiteral(val);
}
/**
 * Convert a js object into typescript AST
 * @param obj key value object
 * @returns Typescript Object Literal Expression
 */
function objectToObjectLiteral(obj) {
    if (Object.keys(obj).length === 0) {
        return ts.createObjectLiteral([]);
    }
    const newProperties = Object.keys(obj).map((key) => {
        return ts.createPropertyAssignment(ts.createLiteral(key), convertValueToLiteral(obj[key]));
    });
    return ts.createObjectLiteral(newProperties, true);
}
/**
 * Convert a js array into typescript AST
 * @param list array
 * @returns Typescript Array Literal Expression
 */
function arrayToArrayLiteral(list) {
    const newList = list.map(convertValueToLiteral);
    return ts.createArrayLiteral(newList);
}

function formatConstructorEncapsulation(encapsulation) {
    if (encapsulation) {
        if (encapsulation === 1 /* ShadowDom */) {
            return 'shadow';
        }
        else if (encapsulation === 2 /* ScopedCss */) {
            return 'scoped';
        }
    }
    return null;
}
function formatComponentConstructorProperties(membersMeta, stringify, excludeInternal) {
    if (!membersMeta) {
        return null;
    }
    const memberNames = Object.keys(membersMeta).sort((a, b) => {
        if (a.toLowerCase() < b.toLowerCase())
            return -1;
        if (a.toLowerCase() > b.toLowerCase())
            return 1;
        return 0;
    });
    if (!memberNames.length) {
        return null;
    }
    const properties = {};
    memberNames.forEach(memberName => {
        const prop = formatComponentConstructorProperty(membersMeta[memberName], stringify, excludeInternal);
        if (prop !== null) {
            properties[memberName] = prop;
        }
    });
    if (!Object.keys(properties).length) {
        return null;
    }
    if (stringify) {
        let str = JSON.stringify(properties);
        str = str.replace(`"TYPE_String"`, `String`);
        str = str.replace(`"TYPE_Boolean"`, `Boolean`);
        str = str.replace(`"TYPE_Number"`, `Number`);
        return str;
    }
    return properties;
}
function formatComponentConstructorProperty(memberMeta, stringify, excludeInternal) {
    const property = {};
    if (memberMeta.memberType === 16 /* State */) {
        if (excludeInternal)
            return null;
        property.state = true;
    }
    else if (memberMeta.memberType === 64 /* Element */) {
        if (excludeInternal)
            return null;
        property.elementRef = true;
    }
    else if (memberMeta.memberType === 32 /* Method */) {
        property.method = true;
    }
    else if (memberMeta.memberType === 8 /* PropConnect */) {
        if (excludeInternal)
            return null;
        property.connect = memberMeta.ctrlId;
    }
    else if (memberMeta.memberType === 4 /* PropContext */) {
        if (excludeInternal)
            return null;
        property.context = memberMeta.ctrlId;
    }
    else {
        if (memberMeta.propType === 2 /* String */) {
            if (stringify) {
                property.type = 'TYPE_String';
            }
            else {
                property.type = String;
            }
        }
        else if (memberMeta.propType === 4 /* Boolean */) {
            if (stringify) {
                property.type = 'TYPE_Boolean';
            }
            else {
                property.type = Boolean;
            }
        }
        else if (memberMeta.propType === 8 /* Number */) {
            if (stringify) {
                property.type = 'TYPE_Number';
            }
            else {
                property.type = Number;
            }
        }
        else {
            property.type = 'Any';
        }
        if (typeof memberMeta.attribName === 'string') {
            property.attr = memberMeta.attribName;
            if (memberMeta.reflectToAttrib) {
                property.reflectToAttr = true;
            }
        }
        if (memberMeta.memberType === 2 /* PropMutable */) {
            property.mutable = true;
        }
    }
    if (memberMeta.watchCallbacks && memberMeta.watchCallbacks.length > 0) {
        property.watchCallbacks = memberMeta.watchCallbacks.slice();
    }
    return property;
}
function formatComponentConstructorEvents(eventsMeta) {
    if (!eventsMeta || !eventsMeta.length) {
        return null;
    }
    return eventsMeta.map(ev => formatComponentConstructorEvent(ev));
}
function formatComponentConstructorEvent(eventMeta) {
    const constructorEvent = {
        name: eventMeta.eventName,
        method: eventMeta.eventMethodName,
        bubbles: true,
        cancelable: true,
        composed: true
    };
    // default bubbles true
    if (typeof eventMeta.eventBubbles === 'boolean') {
        constructorEvent.bubbles = eventMeta.eventBubbles;
    }
    // default cancelable true
    if (typeof eventMeta.eventCancelable === 'boolean') {
        constructorEvent.cancelable = eventMeta.eventCancelable;
    }
    // default composed true
    if (typeof eventMeta.eventComposed === 'boolean') {
        constructorEvent.composed = eventMeta.eventComposed;
    }
    return constructorEvent;
}
function formatComponentConstructorListeners(listenersMeta, stringify) {
    if (!listenersMeta || !listenersMeta.length) {
        return null;
    }
    const listeners = listenersMeta.map(ev => formatComponentConstructorListener(ev));
    if (stringify) {
        return JSON.stringify(listeners);
    }
    return listeners;
}
function formatComponentConstructorListener(listenMeta) {
    const constructorListener = {
        name: listenMeta.eventName,
        method: listenMeta.eventMethodName
    };
    // default capture falsy
    if (listenMeta.eventCapture === true) {
        constructorListener.capture = true;
    }
    // default disabled falsy
    if (listenMeta.eventDisabled === true) {
        constructorListener.disabled = true;
    }
    // default passive falsy
    if (listenMeta.eventPassive === true) {
        constructorListener.passive = true;
    }
    return constructorListener;
}
function getStylePlaceholder(tagName) {
    return `/**style-placeholder:${tagName}:**/`;
}
function getStyleIdPlaceholder(tagName) {
    return `/**style-id-placeholder:${tagName}:**/`;
}

function addComponentMetadata(moduleFiles) {
    return (transformContext) => {
        function visitClass(classNode, cmpMeta) {
            const staticMembers = addStaticMeta(cmpMeta);
            const newMembers = Object.keys(staticMembers).map(memberName => {
                return createGetter(memberName, staticMembers[memberName]);
            });
            return ts.updateClassDeclaration(classNode, classNode.decorators, classNode.modifiers, classNode.name, classNode.typeParameters, classNode.heritageClauses, [...classNode.members, ...newMembers]);
        }
        function visit(node, cmpMeta) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    return visitClass(node, cmpMeta);
                default:
                    return ts.visitEachChild(node, (node) => {
                        return visit(node, cmpMeta);
                    }, transformContext);
            }
        }
        return (tsSourceFile) => {
            const moduleFile = moduleFiles[tsSourceFile.fileName];
            if (moduleFile && moduleFile.cmpMeta) {
                return visit(tsSourceFile, moduleFile.cmpMeta);
            }
            return tsSourceFile;
        };
    };
}
function addStaticMeta(cmpMeta) {
    const staticMembers = {};
    staticMembers.is = convertValueToLiteral(cmpMeta.tagNameMeta);
    const encapsulation = formatConstructorEncapsulation(cmpMeta.encapsulationMeta);
    if (encapsulation) {
        staticMembers.encapsulation = convertValueToLiteral(encapsulation);
    }
    if (cmpMeta.hostMeta && Object.keys(cmpMeta.hostMeta).length > 0) {
        staticMembers.host = convertValueToLiteral(cmpMeta.hostMeta);
    }
    const propertiesMeta = formatComponentConstructorProperties(cmpMeta.membersMeta);
    if (propertiesMeta && Object.keys(propertiesMeta).length > 0) {
        staticMembers.properties = convertValueToLiteral(propertiesMeta);
    }
    const eventsMeta = formatComponentConstructorEvents(cmpMeta.eventsMeta);
    if (eventsMeta && eventsMeta.length > 0) {
        staticMembers.events = convertValueToLiteral(eventsMeta);
    }
    const listenerMeta = formatComponentConstructorListeners(cmpMeta.listenersMeta);
    if (listenerMeta && listenerMeta.length > 0) {
        staticMembers.listeners = convertValueToLiteral(listenerMeta);
    }
    if (cmpMeta.stylesMeta) {
        const styleModes = Object.keys(cmpMeta.stylesMeta);
        if (styleModes.length > 0) {
            // awesome, we know we've got styles!
            // let's add the placeholder which we'll use later
            // after we generate the css
            staticMembers.style = convertValueToLiteral(getStylePlaceholder(cmpMeta.tagNameMeta));
            if (!cmpMeta.stylesMeta[DEFAULT_STYLE_MODE]) {
                // if there's only one style, then there's no need for styleId
                // but if there are numerous style modes, then we'll need to add this
                staticMembers.styleMode = convertValueToLiteral(getStyleIdPlaceholder(cmpMeta.tagNameMeta));
            }
        }
    }
    return staticMembers;
}
function createGetter(name, returnExpression) {
    return ts.createGetAccessor(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], name, undefined, undefined, ts.createBlock([
        ts.createReturn(returnExpression)
    ]));
}

function parseCollectionData(config, collectionName, collectionDir, collectionJsonStr) {
    const collectionData = JSON.parse(collectionJsonStr);
    const collection = {
        collectionName: collectionName,
        dependencies: parseCollectionDependencies(collectionData),
        compiler: {
            name: collectionData.compiler.name,
            version: collectionData.compiler.version,
            typescriptVersion: collectionData.compiler.typescriptVersion
        },
        bundles: []
    };
    parseComponents(config, collectionDir, collectionData, collection);
    parseGlobal(config, collectionDir, collectionData, collection);
    parseBundles(collectionData, collection);
    return collection;
}
function parseComponents(config, collectionDir, collectionData, collection) {
    const componentsData = collectionData.components;
    if (!componentsData || !Array.isArray(componentsData)) {
        collection.moduleFiles = [];
        return;
    }
    collection.moduleFiles = componentsData.map(cmpData => {
        return parseComponentDataToModuleFile(config, collection, collectionDir, cmpData);
    });
}
function parseCollectionDependencies(collectionData) {
    const dependencies = [];
    if (Array.isArray(collectionData.collections)) {
        collectionData.collections.forEach(c => {
            dependencies.push(c.name);
        });
    }
    return dependencies;
}
function excludeFromCollection(config, cmpData) {
    // this is a component from a collection dependency
    // however, this project may also become a collection
    // for example, "ionicons" is a dependency of "ionic"
    // and "ionic" is it's own stand-alone collection, so within
    // ionic's collection we want ionicons to just work
    // cmpData is a component from a collection dependency
    // if this component is listed in this config's bundles
    // then we'll need to ensure it also becomes apart of this collection
    const isInBundle = config.bundles && config.bundles.some(bundle => {
        return bundle.components && bundle.components.some(tag => tag === cmpData.tag);
    });
    // if it's not in the config bundle then it's safe to exclude
    // this component from going into this build's collection
    return !isInBundle;
}
function parseComponentDataToModuleFile(config, collection, collectionDir, cmpData) {
    const moduleFile = {
        sourceFilePath: normalizePath(config.sys.path.join(collectionDir, cmpData.componentPath)),
        cmpMeta: {},
        isCollectionDependency: true,
        excludeFromCollection: excludeFromCollection(config, cmpData),
        localImports: [],
        externalImports: [],
        potentialCmpRefs: []
    };
    const cmpMeta = moduleFile.cmpMeta;
    parseTag(cmpData, cmpMeta);
    parseComponentDependencies(cmpData, cmpMeta);
    parseComponentClass(cmpData, cmpMeta);
    parseModuleJsFilePath(config, collectionDir, cmpData, moduleFile);
    parseStyles(config, collectionDir, cmpData, cmpMeta);
    parseAssetsDir(config, collectionDir, cmpData, cmpMeta);
    parseProps(config, collection, cmpData, cmpMeta);
    parseStates(cmpData, cmpMeta);
    parseListeners(cmpData, cmpMeta);
    parseMethods(cmpData, cmpMeta);
    parseContextMember(cmpData, cmpMeta);
    parseConnectMember(cmpData, cmpMeta);
    parseHostElementMember(cmpData, cmpMeta);
    parseEvents(cmpData, cmpMeta);
    parseHost(cmpData, cmpMeta);
    parseEncapsulation(cmpData, cmpMeta);
    // DEPRECATED: 2017-12-27
    parseWillChangeDeprecated(cmpData, cmpMeta);
    parseDidChangeDeprecated(cmpData, cmpMeta);
    return moduleFile;
}
function parseTag(cmpData, cmpMeta) {
    cmpMeta.tagNameMeta = cmpData.tag;
}
function parseModuleJsFilePath(config, collectionDir, cmpData, moduleFile) {
    // convert the path that's relative to the collection file
    // into an absolute path to the component's js file path
    if (typeof cmpData.componentPath !== 'string') {
        throw new Error(`parseModuleJsFilePath, "componentPath" missing on cmpData: ${cmpData.tag}`);
    }
    moduleFile.jsFilePath = normalizePath(config.sys.path.join(collectionDir, cmpData.componentPath));
    // remember the original component path from its collection
    moduleFile.originalCollectionComponentPath = cmpData.componentPath;
}
function parseComponentDependencies(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.dependencies)) {
        cmpMeta.dependencies = [];
    }
    else {
        cmpMeta.dependencies = cmpData.dependencies.sort();
    }
}
function parseComponentClass(cmpData, cmpMeta) {
    cmpMeta.componentClass = cmpData.componentClass;
}
function parseStyles(config, collectionDir, cmpData, cmpMeta) {
    const stylesData = cmpData.styles;
    cmpMeta.stylesMeta = {};
    if (stylesData) {
        Object.keys(stylesData).forEach(modeName => {
            modeName = modeName.toLowerCase();
            cmpMeta.stylesMeta[modeName] = parseStyle(config, collectionDir, cmpData, stylesData[modeName]);
        });
    }
}
function parseStyle(config, collectionDir, cmpData, modeStyleData) {
    const modeStyle = {
        styleStr: modeStyleData.style
    };
    if (modeStyleData.stylePaths) {
        modeStyle.externalStyles = modeStyleData.stylePaths.map(stylePath => {
            const externalStyle = {};
            externalStyle.absolutePath = normalizePath(config.sys.path.join(collectionDir, stylePath));
            externalStyle.cmpRelativePath = normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), stylePath));
            externalStyle.originalCollectionPath = normalizePath(stylePath);
            return externalStyle;
        });
    }
    return modeStyle;
}
function parseAssetsDir(config, collectionDir, cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.assetPaths)) {
        return;
    }
    cmpMeta.assetsDirsMeta = cmpData.assetPaths.map(assetsPath => {
        const assetsMeta = {
            absolutePath: normalizePath(config.sys.path.join(collectionDir, assetsPath)),
            cmpRelativePath: normalizePath(config.sys.path.relative(config.sys.path.dirname(cmpData.componentPath), assetsPath)),
            originalCollectionPath: normalizePath(assetsPath)
        };
        return assetsMeta;
    }).sort((a, b) => {
        if (a.cmpRelativePath < b.cmpRelativePath)
            return -1;
        if (a.cmpRelativePath > b.cmpRelativePath)
            return 1;
        return 0;
    });
}
function parseProps(config, collection, cmpData, cmpMeta) {
    const propsData = cmpData.props;
    if (invalidArrayData(propsData)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    propsData.forEach(propData => {
        cmpMeta.membersMeta[propData.name] = {};
        if (propData.mutable) {
            cmpMeta.membersMeta[propData.name].memberType = 2 /* PropMutable */;
        }
        else {
            cmpMeta.membersMeta[propData.name].memberType = 1 /* Prop */;
        }
        // the standard is the first character of the type is capitalized
        // however, lowercase and normalize for good measure
        const type = typeof propData.type === 'string' ? propData.type.toLowerCase().trim() : null;
        if (type === BOOLEAN_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 4 /* Boolean */;
        }
        else if (type === NUMBER_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 8 /* Number */;
        }
        else if (type === STRING_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 2 /* String */;
        }
        else if (type === ANY_KEY.toLowerCase()) {
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        else if (!collection.compiler || !collection.compiler.version || config.sys.semver.lt(collection.compiler.version, '0.0.6-23')) {
            // older compilers didn't remember "any" type
            cmpMeta.membersMeta[propData.name].propType = 1 /* Any */;
        }
        if (cmpMeta.membersMeta[propData.name].propType) {
            // deprecated 0.7.3, 2018-03-19
            cmpMeta.membersMeta[propData.name].attribName = propData.name;
        }
        if (typeof propData.attr === 'string') {
            cmpMeta.membersMeta[propData.name].attribName = propData.attr;
        }
        if (!invalidArrayData(propData.watch)) {
            cmpMeta.membersMeta[propData.name].watchCallbacks = propData.watch.slice().sort();
        }
    });
}
function parseWillChangeDeprecated(cmpData, cmpMeta) {
    // DEPRECATED: 2017-12-27
    // previous way of storing change, 0.1.0 and below
    const propWillChangeData = cmpData.propsWillChange;
    if (invalidArrayData(propWillChangeData)) {
        return;
    }
    propWillChangeData.forEach((willChangeData) => {
        const propName = willChangeData.name;
        const methodName = willChangeData.method;
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta[propName] = cmpMeta.membersMeta[propName] || {};
        cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
        cmpMeta.membersMeta[propName].watchCallbacks.push(methodName);
    });
}
function parseDidChangeDeprecated(cmpData, cmpMeta) {
    // DEPRECATED: 2017-12-27
    // previous way of storing change, 0.1.0 and below
    const propDidChangeData = cmpData.propsDidChange;
    if (invalidArrayData(propDidChangeData)) {
        return;
    }
    propDidChangeData.forEach((didChangeData) => {
        const propName = didChangeData.name;
        const methodName = didChangeData.method;
        cmpMeta.membersMeta = cmpMeta.membersMeta || {};
        cmpMeta.membersMeta[propName] = cmpMeta.membersMeta[propName] || {};
        cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
        cmpMeta.membersMeta[propName].watchCallbacks.push(methodName);
    });
}
function parseStates(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.states)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.states.forEach(stateData => {
        cmpMeta.membersMeta[stateData.name] = {
            memberType: 16 /* State */
        };
    });
}
function parseListeners(cmpData, cmpMeta) {
    const listenersData = cmpData.listeners;
    if (invalidArrayData(listenersData)) {
        return;
    }
    cmpMeta.listenersMeta = listenersData.map(listenerData => {
        const listener = {
            eventName: listenerData.event,
            eventMethodName: listenerData.method,
            eventPassive: (listenerData.passive !== false),
            eventDisabled: (listenerData.enabled === false),
            eventCapture: (listenerData.capture !== false)
        };
        return listener;
    });
}
function parseMethods(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.methods)) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpData.methods.forEach(methodData => {
        cmpMeta.membersMeta[methodData.name] = {
            memberType: 32 /* Method */
        };
    });
}
function parseContextMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.context)) {
        return;
    }
    cmpData.context.forEach(methodData => {
        if (methodData.id) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 4 /* PropContext */,
                ctrlId: methodData.id
            };
        }
    });
}
function parseConnectMember(cmpData, cmpMeta) {
    if (invalidArrayData(cmpData.connect)) {
        return;
    }
    cmpData.connect.forEach(methodData => {
        if (methodData.tag) {
            cmpMeta.membersMeta = cmpMeta.membersMeta || {};
            cmpMeta.membersMeta[methodData.name] = {
                memberType: 8 /* PropConnect */,
                ctrlId: methodData.tag
            };
        }
    });
}
function parseHostElementMember(cmpData, cmpMeta) {
    if (!cmpData.hostElement) {
        return;
    }
    cmpMeta.membersMeta = cmpMeta.membersMeta || {};
    cmpMeta.membersMeta[cmpData.hostElement.name] = {
        memberType: 64 /* Element */
    };
}
function parseEvents(cmpData, cmpMeta) {
    const eventsData = cmpData.events;
    if (invalidArrayData(eventsData)) {
        return;
    }
    cmpMeta.eventsMeta = eventsData.map(eventData => ({
        eventName: eventData.event,
        eventMethodName: (eventData.method) ? eventData.method : eventData.event,
        eventBubbles: (eventData.bubbles !== false),
        eventCancelable: (eventData.cancelable !== false),
        eventComposed: (eventData.composed !== false)
    }));
}
function parseHost(cmpData, cmpMeta) {
    if (!cmpData.host) {
        return;
    }
    cmpMeta.hostMeta = cmpData.host;
}
function parseEncapsulation(cmpData, cmpMeta) {
    if (cmpData.shadow === true) {
        cmpMeta.encapsulationMeta = 1 /* ShadowDom */;
    }
    else if (cmpData.scoped === true) {
        cmpMeta.encapsulationMeta = 2 /* ScopedCss */;
    }
    else {
        cmpMeta.encapsulationMeta = 0 /* NoEncapsulation */;
    }
}
function parseGlobal(config, collectionDir, collectionData, collection) {
    if (typeof collectionData.global !== 'string')
        return;
    collection.global = {
        sourceFilePath: normalizePath(config.sys.path.join(collectionDir, collectionData.global)),
        jsFilePath: normalizePath(config.sys.path.join(collectionDir, collectionData.global)),
        localImports: [],
        externalImports: [],
        potentialCmpRefs: []
    };
}
function parseBundles(collectionData, collection) {
    if (invalidArrayData(collectionData.bundles)) {
        collection.bundles = [];
        return;
    }
    collection.bundles = collectionData.bundles.map(b => {
        return {
            components: b.components.slice().sort()
        };
    });
}
function invalidArrayData(arr) {
    return (!arr || !Array.isArray(arr) || arr.length === 0);
}
const BOOLEAN_KEY = 'Boolean';
const NUMBER_KEY = 'Number';
const STRING_KEY = 'String';
const ANY_KEY = 'Any';

function parseCollectionModule(config, compilerCtx, pkgJsonFilePath, pkgData) {
    // note this MUST be synchronous because this is used during transpile
    const collectionName = pkgData.name;
    let collection = compilerCtx.collections.find(c => c.collectionName === collectionName);
    if (collection) {
        // we've already cached the collection, no need for another resolve/readFile/parse
        // thought being that /node_modules/ isn't changing between watch builds
        return collection;
    }
    // get the root directory of the dependency
    const collectionPackageRootDir = config.sys.path.dirname(pkgJsonFilePath);
    // figure out the full path to the collection collection file
    const collectionFilePath = pathJoin(config, collectionPackageRootDir, pkgData.collection);
    const relPath = config.sys.path.relative(config.rootDir, collectionFilePath);
    config.logger.debug(`load collection: ${collectionName}, ${relPath}`);
    // we haven't cached the collection yet, let's read this file
    // sync on purpose :(
    const collectionJsonStr = compilerCtx.fs.readFileSync(collectionFilePath);
    // get the directory where the collection collection file is sitting
    const collectionDir = normalizePath(config.sys.path.dirname(collectionFilePath));
    // parse the json string into our collection data
    collection = parseCollectionData(config, collectionName, collectionDir, collectionJsonStr);
    if (pkgData.module && pkgData.module !== pkgData.main) {
        collection.hasExports = true;
    }
    // remember the source of this collection node_module
    collection.moduleDir = collectionPackageRootDir;
    // append any collection data
    collection.moduleFiles.forEach(collectionModuleFile => {
        if (!compilerCtx.moduleFiles[collectionModuleFile.jsFilePath]) {
            compilerCtx.moduleFiles[collectionModuleFile.jsFilePath] = collectionModuleFile;
        }
    });
    // cache it for later yo
    compilerCtx.collections.push(collection);
    return collection;
}

function getCollections(config, compilerCtx, collections, moduleFile, importNode) {
    if (!importNode.moduleSpecifier || !compilerCtx || !collections) {
        return;
    }
    const moduleId = importNode.moduleSpecifier.text;
    // see if we can add this collection dependency
    addCollection(config, compilerCtx, collections, moduleFile, config.rootDir, moduleId);
}
function addCollection(config, compilerCtx, collections, moduleFile, resolveFromDir, moduleId) {
    if (moduleId.startsWith('.') || moduleId.startsWith('/')) {
        // not a node module import, so don't bother
        return;
    }
    moduleFile.externalImports = moduleFile.externalImports || [];
    if (!moduleFile.externalImports.includes(moduleId)) {
        moduleFile.externalImports.push(moduleId);
        moduleFile.externalImports.sort();
    }
    if (compilerCtx.resolvedCollections.includes(moduleId)) {
        // we've already handled this collection moduleId before
        return;
    }
    // cache that we've already parsed this
    compilerCtx.resolvedCollections.push(moduleId);
    let pkgJsonFilePath;
    try {
        // get the full package.json file path
        pkgJsonFilePath = normalizePath(config.sys.resolveModule(resolveFromDir, moduleId));
    }
    catch (e) {
        // it's someone else's job to handle unresolvable paths
        return;
    }
    if (pkgJsonFilePath === 'package.json') {
        // the resolved package is actually this very same package, so whatever
        return;
    }
    // open up and parse the package.json
    // sync on purpose :(
    const pkgJsonStr = compilerCtx.fs.readFileSync(pkgJsonFilePath);
    const pkgData = JSON.parse(pkgJsonStr);
    if (!pkgData.collection || !pkgData.types) {
        // this import is not a stencil collection
        return;
    }
    // this import is a stencil collection
    // let's parse it and gather all the module data about it
    // internally it'll cached collection data if we've already done this
    const collection = parseCollectionModule(config, compilerCtx, pkgJsonFilePath, pkgData);
    // check if we already added this collection to the build context
    const alreadyHasCollection = collections.some(c => {
        return c.collectionName === collection.collectionName;
    });
    if (alreadyHasCollection) {
        // we already have this collection in our build context
        return;
    }
    // let's add the collection to the build context
    collections.push(collection);
    if (Array.isArray(collection.dependencies)) {
        // this collection has more collections
        // let's keep digging down and discover all of them
        collection.dependencies.forEach(dependencyModuleId => {
            const resolveFromDir = config.sys.path.dirname(pkgJsonFilePath);
            addCollection(config, compilerCtx, collections, moduleFile, resolveFromDir, dependencyModuleId);
        });
    }
}

function evalText(text) {
    const fnStr = `return ${text};`;
    return new Function(fnStr)();
}
const getDeclarationParameters = (decorator) => {
    if (!ts.isCallExpression(decorator.expression)) {
        return [];
    }
    return decorator.expression.arguments.map((arg) => {
        return evalText(arg.getText().trim());
    });
};
function isDecoratorNamed(name) {
    return (dec) => {
        return (ts.isCallExpression(dec.expression) && dec.expression.expression.getText() === name);
    };
}
function isPropertyWithDecorators(member) {
    return ts.isPropertyDeclaration(member)
        && Array.isArray(member.decorators)
        && member.decorators.length > 0;
}
function isMethodWithDecorators(member) {
    return ts.isMethodDeclaration(member)
        && Array.isArray(member.decorators)
        && member.decorators.length > 0;
}
function serializeSymbol(checker, symbol) {
    return {
        name: symbol.getName(),
        documentation: ts.displayPartsToString(symbol.getDocumentationComment(checker)),
        type: checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration))
    };
}
function isMethod(member, methodName) {
    if (ts.isMethodDeclaration(member)) {
        return member.getFirstToken().getText() === methodName;
    }
    return false;
}
function getAttributeTypeInfo(baseNode, sourceFile) {
    return getAllTypeReferences(baseNode)
        .reduce((allReferences, rt) => {
        allReferences[rt] = getTypeReferenceLocation(rt, sourceFile);
        return allReferences;
    }, {});
}
function getAllTypeReferences(node) {
    const referencedTypes = [];
    function visit(node) {
        switch (node.kind) {
            case ts.SyntaxKind.TypeReference:
                const typeNode = node;
                if (ts.isIdentifier(typeNode.typeName)) {
                    const name = typeNode.typeName;
                    referencedTypes.push(name.escapedText.toString());
                }
                if (typeNode.typeArguments) {
                    typeNode.typeArguments
                        .filter(ta => ts.isTypeReferenceNode(ta))
                        .forEach((tr) => {
                        const name = tr.typeName;
                        referencedTypes.push(name.escapedText.toString());
                    });
                }
            /* tslint:disable */
            default:
                return ts.forEachChild(node, (node) => {
                    return visit(node);
                });
        }
        /* tslint:enable */
    }
    visit(node);
    return referencedTypes;
}
function getTypeReferenceLocation(typeName, sourceFile) {
    const sourceFileObj = sourceFile.getSourceFile();
    // Loop through all top level imports to find any reference to the type for 'import' reference location
    const importTypeDeclaration = sourceFileObj.statements.find(st => {
        const statement = ts.isImportDeclaration(st) &&
            st.importClause &&
            ts.isImportClause(st.importClause) &&
            st.importClause.namedBindings &&
            ts.isNamedImports(st.importClause.namedBindings) &&
            Array.isArray(st.importClause.namedBindings.elements) &&
            st.importClause.namedBindings.elements.find(nbe => nbe.name.getText() === typeName);
        if (!statement) {
            return false;
        }
        return true;
    });
    if (importTypeDeclaration) {
        const localImportPath = importTypeDeclaration.moduleSpecifier.text;
        return {
            referenceLocation: 'import',
            importReferenceLocation: localImportPath
        };
    }
    // Loop through all top level exports to find if any reference to the type for 'local' reference location
    const isExported = sourceFileObj.statements.some(st => {
        // Is the interface defined in the file and exported
        const isInterfaceDeclarationExported = ((ts.isInterfaceDeclaration(st) &&
            st.name.getText() === typeName) &&
            Array.isArray(st.modifiers) &&
            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
        const isTypeAliasDeclarationExported = ((ts.isTypeAliasDeclaration(st) &&
            st.name.getText() === typeName) &&
            Array.isArray(st.modifiers) &&
            st.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));
        // Is the interface exported through a named export
        const isTypeInExportDeclaration = ts.isExportDeclaration(st) &&
            ts.isNamedExports(st.exportClause) &&
            st.exportClause.elements.some(nee => nee.name.getText() === typeName);
        return isInterfaceDeclarationExported || isTypeAliasDeclarationExported || isTypeInExportDeclaration;
    });
    if (isExported) {
        return {
            referenceLocation: 'local'
        };
    }
    // This is most likely a global type, if it is a local that is not exported then typescript will inform the dev
    return {
        referenceLocation: 'global',
    };
}

function getStylesMeta(componentOptions) {
    let stylesMeta = {};
    if (typeof componentOptions.styles === 'string') {
        // styles: 'div { padding: 10px }'
        componentOptions.styles = componentOptions.styles.trim();
        if (componentOptions.styles.length > 0) {
            stylesMeta = {
                [DEFAULT_STYLE_MODE]: {
                    styleStr: componentOptions.styles
                }
            };
        }
    }
    if (typeof componentOptions.styleUrl === 'string' && componentOptions.styleUrl.trim()) {
        // styleUrl: 'my-styles.css'
        stylesMeta = {
            [DEFAULT_STYLE_MODE]: {
                externalStyles: [{
                        originalComponentPath: componentOptions.styleUrl.trim()
                    }]
            }
        };
    }
    else if (Array.isArray(componentOptions.styleUrls)) {
        // styleUrls: ['my-styles.css', 'my-other-styles']
        stylesMeta = {
            [DEFAULT_STYLE_MODE]: {
                externalStyles: componentOptions.styleUrls.map(styleUrl => {
                    const externalStyle = {
                        originalComponentPath: styleUrl.trim()
                    };
                    return externalStyle;
                })
            }
        };
    }
    else {
        // styleUrls: {
        //   ios: 'badge.ios.css',
        //   md: 'badge.md.css',
        //   wp: 'badge.wp.css'
        // }
        Object.keys(componentOptions.styleUrls || {}).reduce((stylesMeta, styleType) => {
            const styleUrls = componentOptions.styleUrls;
            const sUrls = [].concat(styleUrls[styleType]);
            stylesMeta[styleType] = {
                externalStyles: sUrls.map(sUrl => {
                    const externalStyle = {
                        originalComponentPath: sUrl
                    };
                    return externalStyle;
                })
            };
            return stylesMeta;
        }, stylesMeta);
    }
    return stylesMeta;
}

function getComponentDecoratorMeta(diagnostics, checker, node) {
    if (!node.decorators) {
        return undefined;
    }
    const componentDecorator = node.decorators.find(isDecoratorNamed('Component'));
    if (!componentDecorator) {
        return undefined;
    }
    const [componentOptions] = getDeclarationParameters(componentDecorator);
    if (!componentOptions.tag || componentOptions.tag.trim() === '') {
        throw new Error(`tag missing in component decorator: ${JSON.stringify(componentOptions, null, 2)}`);
    }
    if (node.heritageClauses && node.heritageClauses.some(c => c.token === ts.SyntaxKind.ExtendsKeyword)) {
        throw new Error(`Classes decorated with @Component can not extend from a base class.
  Inherency is temporarily disabled for stencil components.`);
    }
    // check if class has more than one decorator
    if (node.decorators.length > 1) {
        throw new Error(`@Component({ tag: "${componentOptions.tag}" }) can not be decorated with more decorators at the same time`);
    }
    if (componentOptions.host) {
        const warn = buildWarn(diagnostics);
        warn.header = 'Host prop deprecated';
        warn.messageText = `The “host” property used in @Component({ tag: "${componentOptions.tag}" }) has been deprecated.
It will be removed in future versions. Please use the "hostData()" method instead. `;
    }
    const symbol = checker.getSymbolAtLocation(node.name);
    const cmpMeta = {
        tagNameMeta: componentOptions.tag,
        stylesMeta: getStylesMeta(componentOptions),
        assetsDirsMeta: [],
        hostMeta: getHostMeta(diagnostics, componentOptions.host),
        dependencies: [],
        jsdoc: serializeSymbol(checker, symbol)
    };
    // normalizeEncapsulation
    cmpMeta.encapsulationMeta =
        componentOptions.shadow ? 1 /* ShadowDom */ :
            componentOptions.scoped ? 2 /* ScopedCss */ :
                0 /* NoEncapsulation */;
    // assetsDir: './somedir'
    if (componentOptions.assetsDir) {
        const assetsMeta = {
            originalComponentPath: componentOptions.assetsDir
        };
        cmpMeta.assetsDirsMeta.push(assetsMeta);
    }
    // assetsDirs: ['./somedir', '../someotherdir']
    if (Array.isArray(componentOptions.assetsDirs)) {
        cmpMeta.assetsDirsMeta = cmpMeta.assetsDirsMeta.concat(componentOptions.assetsDirs.map(assetDir => ({ originalComponentPath: assetDir })));
    }
    return cmpMeta;
}
function getHostMeta(diagnostics, hostData) {
    hostData = hostData || {};
    Object.keys(hostData).forEach(key => {
        const type = typeof hostData[key];
        if (type !== 'string' && type !== 'number' && type !== 'boolean') {
            // invalid data
            delete hostData[key];
            let itsType = 'object';
            if (type === 'function') {
                itsType = 'function';
            }
            else if (Array.isArray(hostData[key])) {
                itsType = 'Array';
            }
            const diagnostic = buildWarn(diagnostics);
            diagnostic.messageText = [
                `The @Component decorator's host property "${key}" has a type of "${itsType}". `,
                `However, a @Component decorator's "host" can only take static data, `,
                `such as a string, number or boolean. `,
                `Please use the "hostData()" method instead `,
                `if attributes or properties need to be dynamically added to `,
                `the host element.`
            ].join('');
        }
    });
    return hostData;
}

function getElementDecoratorMeta(checker, classNode) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('Element'));
        if (elementDecorator) {
            membersMeta[member.name.getText()] = {
                memberType: 64 /* Element */
            };
        }
        return membersMeta;
    }, {});
}

function getEventDecoratorMeta(diagnostics, checker, classNode, sourceFile) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('Event'));
        if (elementDecorator == null) {
            return membersMeta;
        }
        const [eventOptions] = getDeclarationParameters(elementDecorator);
        const metadata = convertOptionsToMeta(diagnostics, eventOptions, member.name.getText());
        if (member.type) {
            const genericType = gatherEventEmitterGeneric(member.type);
            if (genericType) {
                metadata.eventType = {
                    text: genericType.getText(),
                    optional: false
                };
                if (ts.isTypeReferenceNode(genericType)) {
                    metadata.eventType.typeReferences = getAttributeTypeInfo(member, sourceFile);
                }
            }
        }
        if (metadata) {
            const symbol = checker.getSymbolAtLocation(member.name);
            metadata.jsdoc = serializeSymbol(checker, symbol);
            metadata.jsdoc.name = metadata.eventName;
            membersMeta.push(metadata);
        }
        return membersMeta;
    }, []);
}
function convertOptionsToMeta(diagnostics, rawEventOpts = {}, memberName) {
    if (!memberName) {
        return null;
    }
    return {
        eventMethodName: memberName,
        eventName: getEventName(diagnostics, rawEventOpts, memberName),
        eventBubbles: typeof rawEventOpts.bubbles === 'boolean' ? rawEventOpts.bubbles : true,
        eventCancelable: typeof rawEventOpts.cancelable === 'boolean' ? rawEventOpts.cancelable : true,
        eventComposed: typeof rawEventOpts.composed === 'boolean' ? rawEventOpts.composed : true
    };
}
function getEventName(diagnostics, rawEventOpts, memberName) {
    if (typeof rawEventOpts.eventName === 'string' && rawEventOpts.eventName.trim().length > 0) {
        // always use the event name if given
        return rawEventOpts.eventName.trim();
    }
    // event name wasn't provided
    // so let's default to use the member name
    validateEventEmitterMemeberName(diagnostics, memberName);
    return memberName;
}
function validateEventEmitterMemeberName(diagnostics, memberName) {
    const firstChar = memberName.charAt(0);
    if (/[A-Z]/.test(firstChar)) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = [
            `In order to be compatible with all event listeners on elements, the `,
            `@Event() "${memberName}" cannot start with a capital letter. `,
            `Please lowercase the first character for the event to best work with all listeners.`
        ].join('');
    }
}
function gatherEventEmitterGeneric(type) {
    if (ts.isTypeReferenceNode(type) &&
        ts.isIdentifier(type.typeName) &&
        type.typeName.text === 'EventEmitter' &&
        type.typeArguments &&
        type.typeArguments.length > 0) {
        const eeGen = type.typeArguments[0];
        return eeGen;
    }
    return null;
}

function getListenDecoratorMeta(checker, classNode) {
    const listeners = [];
    classNode.members
        .filter(isMethodWithDecorators)
        .forEach(member => {
        member.decorators
            .filter(isDecoratorNamed('Listen'))
            .map(dec => getDeclarationParameters(dec))
            .forEach(([listenText, listenOptions]) => {
            listenText.split(',').forEach(eventName => {
                const symbol = checker.getSymbolAtLocation(member.name);
                const jsdoc = serializeSymbol(checker, symbol);
                listeners.push(Object.assign({}, validateListener(eventName.trim(), listenOptions, member.name.getText()), { jsdoc }));
            });
        });
    });
    return listeners;
}
function validateListener(eventName, rawListenOpts = {}, methodName) {
    let rawEventName = eventName;
    let splt = eventName.split(':');
    if (splt.length > 2) {
        throw new Error(`@Listen can only contain one colon: ${eventName}`);
    }
    if (splt.length > 1) {
        const prefix = splt[0].toLowerCase().trim();
        if (!isValidElementRefPrefix(prefix)) {
            throw new Error(`invalid @Listen prefix "${prefix}" for "${eventName}"`);
        }
        rawEventName = splt[1].toLowerCase().trim();
    }
    splt = rawEventName.split('.');
    if (splt.length > 2) {
        throw new Error(`@Listen can only contain one period: ${eventName}`);
    }
    if (splt.length > 1) {
        const suffix = splt[1].toLowerCase().trim();
        if (!isValidKeycodeSuffix(suffix)) {
            throw new Error(`invalid @Listen suffix "${suffix}" for "${eventName}"`);
        }
        rawEventName = splt[0].toLowerCase().trim();
    }
    const listenMeta = {
        eventName: eventName,
        eventMethodName: methodName
    };
    listenMeta.eventCapture = (typeof rawListenOpts.capture === 'boolean') ? rawListenOpts.capture : false;
    listenMeta.eventPassive = (typeof rawListenOpts.passive === 'boolean') ? rawListenOpts.passive :
        // if the event name is kown to be a passive event then set it to true
        (PASSIVE_TRUE_DEFAULTS.indexOf(rawEventName.toLowerCase()) > -1);
    // default to enabled=true if it wasn't provided
    listenMeta.eventDisabled = (rawListenOpts.enabled === false);
    return listenMeta;
}
function isValidElementRefPrefix(prefix) {
    return (VALID_ELEMENT_REF_PREFIXES.indexOf(prefix) > -1);
}
function isValidKeycodeSuffix(prefix) {
    return (VALID_KEYCODE_SUFFIX.indexOf(prefix) > -1);
}
const PASSIVE_TRUE_DEFAULTS = [
    'dragstart', 'drag', 'dragend', 'dragenter', 'dragover', 'dragleave', 'drop',
    'mouseenter', 'mouseover', 'mousemove', 'mousedown', 'mouseup', 'mouseleave', 'mouseout', 'mousewheel',
    'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave',
    'resize',
    'scroll',
    'touchstart', 'touchmove', 'touchend', 'touchenter', 'touchleave', 'touchcancel',
    'wheel',
];
const VALID_ELEMENT_REF_PREFIXES = [
    'child', 'parent', 'body', 'document', 'window'
];
const VALID_KEYCODE_SUFFIX = [
    'enter', 'escape', 'space', 'tab', 'up', 'right', 'down', 'left'
];

function validatePublicName(diagnostics, componentClass, memberName, decorator, memberType) {
    if (isReservedMember(memberName)) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = [
            `The ${decorator} name "${memberName}" used within the "${componentClass}" class is a reserved public name. `,
            `Please rename the "${memberName}" ${memberType} so it does not conflict with an existing standardized prototype member. `,
            `Reusing ${memberType} names that are already defined on the element's prototype may cause `,
            `unexpected runtime errors or user-interface issues on various browsers, so it's best to avoid them entirely.`
        ].join('');
    }
}
const READ_ONLY_PROPERTIES = [
    'attributes',
    'baseURI',
    'childElementCount',
    'childNodes',
    'children',
    'classList',
    'clientHeight',
    'clientLeft',
    'clientTop',
    'clientWidth',
    'contentEditable',
    'dataset',
    'firstChild',
    'firstElementChild',
    'host',
    'is',
    'isConnected',
    'isContentEditable',
    'lastChild',
    'lastElementChild',
    'localName',
    'namespaceURI',
    'nextElementSibling',
    'nextSibling',
    'nodeName',
    'nodePrincipal',
    'nodeType',
    'nodeValue',
    'offsetHeight',
    'offsetLeft',
    'offsetParent',
    'offsetTop',
    'offsetWidth',
    'ownerDocument',
    'parentElement',
    'parentNode',
    'prefix',
    'previousElementSibling',
    'previousSibling',
    'rootNode',
    'runtimeStyle',
    'scrollHeight',
    'scrollLeft',
    'scrollLeftMax',
    'scrollTop',
    'scrollTopMax',
    'scrollWidth',
    'shadowRoot',
    'slot',
    'tagName',
    'title',
];
const METHODS = [
    'addEventListener',
    'after',
    'animate',
    'append',
    'appendChild',
    'attachEvent',
    'attachShadow',
    'before',
    'click',
    'cloneNode',
    'closest',
    'compareDocumentPosition',
    'contains',
    'detachEvent',
    'dispatchEvent',
    'fireEvent',
    'getAttribute',
    'getAttributeNames',
    'getAttributeNode',
    'getAttributeNodeNS',
    'getAttributeNS',
    'getBoundingClientRect',
    'getClientRects',
    'getElementsByClassName',
    'getElementsByTagName',
    'getElementsByTagNameNS',
    'getRootNode',
    'getUserData',
    'hasAttribute',
    'hasAttributeNS',
    'hasAttributes',
    'hasChildNodes',
    'insertAdjacentElement',
    'insertAdjacentHTML',
    'insertAdjacentText',
    'insertBefore',
    'isDefaultNamespace',
    'isEqualNode',
    'isSameNode',
    'isSupported',
    'lookupNamespaceURI',
    'lookupPrefix',
    'matches',
    'normalize',
    'prepend',
    'querySelector',
    'querySelectorAll',
    'querySelectorAll',
    'releasePointerCapture',
    'removeChild',
    'remove',
    'removeAttribute',
    'removeAttributeNode',
    'removeAttributeNS',
    'removeEventListener',
    'replaceChild',
    'replaceWith',
    'requestFullscreen',
    'requestPointerLock',
    'scrollIntoView',
    'scrollIntoViewIfNeeded',
    'setAttribute',
    'setAttributeNode',
    'setAttributeNodeNS',
    'setAttributeNS',
    'setCapture',
    'setPointerCapture',
];
const EVENT_HANDLERS = [
    'onabort',
    'onanimationend',
    'onanimationendcapture',
    'onanimationiteration',
    'onanimationiterationcapture',
    'onanimationstart',
    'onanimationstartcapture',
    'onauxclick',
    'onbeforecopy',
    'onbeforecut',
    'onbeforepaste',
    'onblur',
    'onblurcapture',
    'oncancel',
    'oncanplaythrough',
    'onchange',
    'onchangecapture',
    'onclick',
    'onclickcapture',
    'onclose',
    'oncompositionend',
    'oncompositionendcapture',
    'oncompositionstart',
    'oncompositionstartcapture',
    'oncompositionupdate',
    'oncompositionupdatecapture',
    'oncontextmenu',
    'oncontextmenucapture',
    'oncopy',
    'oncopycapture',
    'oncuechange',
    'oncut',
    'oncutcapture',
    'ondblclick',
    'ondblclickcapture',
    'ondrag',
    'ondragcapture',
    'ondragend',
    'ondragendcapture',
    'ondragenter',
    'ondragentercapture',
    'ondragexit',
    'ondragexitcapture',
    'ondragleave',
    'ondragleavecapture',
    'ondragover',
    'ondragovercapture',
    'ondragstart',
    'ondragstartcapture',
    'ondrop',
    'ondropcapture',
    'ondurationchange',
    'onemptied',
    'onended',
    'onerror',
    'onerrorcapture',
    'onfocus',
    'onfocuscapture',
    'onfullscreenchange',
    'onfullscreenerror',
    'ongotpointercapture',
    'oninput',
    'oninputcapture',
    'oninvalid',
    'oninvalidcapture',
    'onkeydown',
    'onkeydowncapture',
    'onkeypress',
    'onkeypresscapture',
    'onkeyup',
    'onkeyupcapture',
    'onload',
    'onloadcapture',
    'onloadeddata',
    'onloadedmetadata',
    'onloadstart',
    'onlostpointercapture',
    'onmousedown',
    'onmousedowncapture',
    'onmouseenter',
    'onmouseleave',
    'onmousemove',
    'onmousemovecapture',
    'onmouseout',
    'onmouseoutcapture',
    'onmouseover',
    'onmouseovercapture',
    'onmouseup',
    'onmouseupcapture',
    'onpaste',
    'onpastecapture',
    'onpause',
    'onplay',
    'onplaying',
    'onpointercancel',
    'onpointerdown',
    'onpointerenter',
    'onpointerleave',
    'onpointermove',
    'onpointerout',
    'onpointerover',
    'onpointerup',
    'onprogress',
    'onratechange',
    'onreset',
    'onresetcapture',
    'onresize',
    'onscroll',
    'onscrollcapture',
    'onsearch',
    'onseeked',
    'onseeking',
    'onselectstart',
    'onstalled',
    'onsubmit',
    'onsubmitcapture',
    'onsuspend',
    'ontimeupdate',
    'ontoggle',
    'ontouchcancel',
    'ontouchcancelcapture',
    'ontouchend',
    'ontouchendcapture',
    'ontouchmove',
    'ontouchmovecapture',
    'ontouchstart',
    'ontouchstartcapture',
    'ontransitionend',
    'ontransitionendcapture',
    'onvolumechange',
    'onwaiting',
    'onwebkitfullscreenchange',
    'onwebkitfullscreenerror',
    'onwheel',
    'onwheelcapture',
];
const RESERVED_PUBLIC_MEMBERS = [
    ...READ_ONLY_PROPERTIES,
    ...METHODS,
    ...EVENT_HANDLERS
].map(p => p.toLowerCase());
function isReservedMember(memberName) {
    memberName = memberName.toLowerCase();
    return RESERVED_PUBLIC_MEMBERS.includes(memberName);
}

function getMethodDecoratorMeta(config, diagnostics, checker, classNode, sourceFile, componentClass) {
    return classNode.members
        .filter(isMethodWithDecorators)
        .reduce((membersMeta, member) => {
        const methodDecorator = member.decorators.find(isDecoratorNamed('Method'));
        if (methodDecorator == null) {
            return membersMeta;
        }
        const symbol = checker.getSymbolAtLocation(member.name);
        const methodName = member.name.getText();
        const methodSignature = checker.getSignatureFromDeclaration(member);
        const flags = ts.TypeFormatFlags.WriteArrowStyleSignature;
        const returnType = checker.getReturnTypeOfSignature(methodSignature);
        const typeString = checker.signatureToString(methodSignature, classNode, flags, ts.SignatureKind.Call);
        if (!config._isTesting && !isPromise(checker, returnType)) {
            const filePath = sourceFile.fileName;
            const warn = buildWarn(diagnostics);
            warn.header = '@Method requires async';
            warn.messageText = `External @Method() ${methodName}() should return a Promise or void.\n\n Consider prefixing the method with async, such as @Method async ${methodName}(). \n Next minor release will error.`;
            warn.absFilePath = normalizePath(filePath);
            warn.relFilePath = normalizePath(config.sys.path.relative(config.rootDir, filePath));
        }
        let methodReturnTypes = {};
        const returnTypeNode = checker.typeToTypeNode(returnType);
        if (returnTypeNode) {
            methodReturnTypes = getAttributeTypeInfo(returnTypeNode, sourceFile);
        }
        validatePublicName(diagnostics, componentClass, methodName, '@Method()', 'method');
        membersMeta[methodName] = {
            memberType: 32 /* Method */,
            attribType: {
                text: typeString,
                optional: false,
                typeReferences: Object.assign({}, methodReturnTypes, getAttributeTypeInfo(member, sourceFile))
            },
            jsdoc: serializeSymbol(checker, symbol)
        };
        return membersMeta;
    }, {});
}
function isPromise(checker, type) {
    if (type.isUnionOrIntersection()) {
        return false;
    }
    const typeText = checker.typeToString(type);
    return typeText === 'void' || typeText.startsWith('Promise<');
}

function getModuleFile(compilerCtx, sourceFilePath) {
    sourceFilePath = normalizePath(sourceFilePath);
    return compilerCtx.moduleFiles[sourceFilePath] = compilerCtx.moduleFiles[sourceFilePath] || {
        sourceFilePath: sourceFilePath,
        localImports: [],
        externalImports: [],
        potentialCmpRefs: []
    };
}

function getPropDecoratorMeta(diagnostics, checker, classNode, sourceFile, componentClass) {
    return classNode.members
        .filter(member => Array.isArray(member.decorators) && member.decorators.length > 0)
        .reduce((allMembers, prop) => {
        const memberData = {};
        const propDecorator = prop.decorators.find(isDecoratorNamed('Prop'));
        if (propDecorator == null) {
            return allMembers;
        }
        const propOptions = getPropOptions(propDecorator, diagnostics);
        const memberName = prop.name.text;
        const symbol = checker.getSymbolAtLocation(prop.name);
        if (propOptions && typeof propOptions.connect === 'string') {
            // @Prop({ connect: 'ion-alert-controller' })
            memberData.memberType = 8 /* PropConnect */;
            memberData.ctrlId = propOptions.connect;
        }
        else if (propOptions && typeof propOptions.context === 'string') {
            // @Prop({ context: 'config' })
            memberData.memberType = 4 /* PropContext */;
            memberData.ctrlId = propOptions.context;
        }
        else {
            // @Prop()
            const type = checker.getTypeAtLocation(prop);
            validatePublicName(diagnostics, componentClass, memberName, '@Prop()', 'property');
            memberData.memberType = getMemberType(propOptions);
            memberData.attribName = getAttributeName(propOptions, memberName);
            memberData.attribType = getAttribType(diagnostics, sourceFile, prop);
            memberData.reflectToAttrib = getReflectToAttr(propOptions);
            memberData.propType = propTypeFromTSType(type);
            memberData.jsdoc = serializeSymbol(checker, symbol);
        }
        allMembers[memberName] = memberData;
        return allMembers;
    }, {});
}
function getPropOptions(propDecorator, diagnostics) {
    const suppliedOptions = propDecorator.expression.arguments
        .map(arg => {
        try {
            const fnStr = `return ${arg.getText()};`;
            return new Function(fnStr)();
        }
        catch (e) {
            catchError(diagnostics, e, `parse prop options: ${e}`);
        }
    });
    const propOptions = suppliedOptions[0];
    return propOptions;
}
function getMemberType(propOptions) {
    if (propOptions && propOptions.mutable === true) {
        return 2 /* PropMutable */;
    }
    return 1 /* Prop */;
}
function getAttributeName(propOptions, memberName) {
    if (propOptions && typeof propOptions.attr === 'string' && propOptions.attr.trim().length > 0) {
        return propOptions.attr.trim();
    }
    return toDashCase(memberName);
}
function getReflectToAttr(propOptions) {
    if (propOptions && propOptions.reflectToAttr === true) {
        return true;
    }
    return false;
}
function getAttribType(diagnostics, sourceFile, prop) {
    let attribType;
    // If the @Prop() attribute does not have a defined type then infer it
    if (!prop.type) {
        let attribTypeText = inferPropType(prop.initializer);
        if (!attribTypeText) {
            attribTypeText = 'any';
            const diagnostic = buildWarn(diagnostics);
            diagnostic.messageText = `Prop type provided is not supported, defaulting to any: '${prop.getFullText()}'`;
        }
        attribType = {
            text: attribTypeText,
            optional: prop.questionToken !== undefined
        };
    }
    else {
        attribType = {
            text: prop.type.getText(),
            optional: prop.questionToken !== undefined,
            typeReferences: getAttributeTypeInfo(prop.type, sourceFile)
        };
    }
    return attribType;
}
function inferPropType(expression) {
    if (expression == null) {
        return undefined;
    }
    if (ts.isStringLiteral(expression)) {
        return 'string';
    }
    if (ts.isNumericLiteral(expression)) {
        return 'number';
    }
    if ([ts.SyntaxKind.BooleanKeyword, ts.SyntaxKind.TrueKeyword, ts.SyntaxKind.FalseKeyword].indexOf(expression.kind) !== -1) {
        return 'boolean';
    }
    if ((ts.SyntaxKind.NullKeyword === expression.kind) ||
        (ts.SyntaxKind.UndefinedKeyword === expression.kind) ||
        (ts.isRegularExpressionLiteral(expression)) ||
        (ts.isArrayLiteralExpression(expression)) ||
        (ts.isObjectLiteralExpression(expression))) {
        return 'any';
    }
    return undefined;
}
function propTypeFromTSType(type) {
    const isStr = checkType(type, isString);
    const isNu = checkType(type, isNumber);
    const isBool = checkType(type, isBoolean);
    const isAnyType = checkType(type, isAny);
    if (isAnyType) {
        return 1 /* Any */;
    }
    // if type is more than a primitive type at the same time, we mark it as any
    if (Number(isStr) + Number(isNu) + Number(isBool) > 1) {
        return 1 /* Any */;
    }
    // at this point we know the prop's type is NOT the mix of primitive types
    if (isStr) {
        return 2 /* String */;
    }
    if (isNu) {
        return 8 /* Number */;
    }
    if (isBool) {
        return 4 /* Boolean */;
    }
    return 0 /* Unknown */;
}
function checkType(type, check) {
    if (type.flags & ts.TypeFlags.Union) {
        const union = type;
        if (union.types.some(type => checkType(type, check))) {
            return true;
        }
    }
    return check(type);
}
function isBoolean(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLike | ts.TypeFlags.BooleanLike));
    }
    return false;
}
function isNumber(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike | ts.TypeFlags.NumberLiteral));
    }
    return false;
}
function isString(t) {
    if (t) {
        return !!(t.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral));
    }
    return false;
}
function isAny(t) {
    if (t) {
        return !!(t.flags & ts.TypeFlags.Any);
    }
    return false;
}

function getStateDecoratorMeta(classNode) {
    return classNode.members
        .filter(isPropertyWithDecorators)
        .reduce((membersMeta, member) => {
        const elementDecorator = member.decorators.find(isDecoratorNamed('State'));
        if (elementDecorator) {
            membersMeta[member.name.getText()] = {
                memberType: 16 /* State */
            };
        }
        return membersMeta;
    }, {});
}

function getWatchDecoratorMeta(diagnostics, classNode, cmpMeta) {
    const methods = classNode.members.filter(isMethodWithDecorators);
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'Watch');
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'PropWillChange');
    getChangeMetaByName(diagnostics, methods, cmpMeta, 'PropDidChange');
}
function getChangeMetaByName(diagnostics, methods, cmpMeta, decoratorName) {
    methods.forEach(({ decorators, name }) => {
        decorators
            .filter(isDecoratorNamed(decoratorName))
            .forEach(propChangeDecorator => {
            const [propName] = getDeclarationParameters(propChangeDecorator);
            if (propName) {
                updateWatchCallback(diagnostics, cmpMeta, propName, name, decoratorName);
            }
        });
    });
}
function updateWatchCallback(diagnostics, cmpMeta, propName, decoratorData, decoratorName) {
    if (!isPropWatchable(cmpMeta, propName)) {
        const error = buildError(diagnostics);
        error.messageText = `@Watch('${propName}') is trying to watch for changes in a property that does not exist.
Make sure only properties decorated with @State() or @Prop() are watched.`;
        return;
    }
    cmpMeta.membersMeta[propName].watchCallbacks = cmpMeta.membersMeta[propName].watchCallbacks || [];
    cmpMeta.membersMeta[propName].watchCallbacks.push(decoratorData.getText());
    if (decoratorName === 'PropWillChange' || decoratorName === 'PropDidChange') {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = `@${decoratorName}('${propName}') decorator within "${cmpMeta.tagNameMeta}" component has been deprecated. Please update to @Watch('${propName}').`;
    }
}
function isPropWatchable(cmpMeta, propName) {
    const membersMeta = cmpMeta.membersMeta;
    if (!membersMeta) {
        return false;
    }
    const member = membersMeta[propName];
    if (!member) {
        return false;
    }
    const type = member.memberType;
    return type === 16 /* State */ || type === 1 /* Prop */ || type === 2 /* PropMutable */;
}

function normalizeAssetsDir(config, componentFilePath, assetsMetas) {
    return assetsMetas.map((assetMeta) => {
        return Object.assign({}, assetMeta, normalizeAssetDir(config, componentFilePath, assetMeta.originalComponentPath));
    });
}
function normalizeAssetDir(config, componentFilePath, assetsDir) {
    const assetsMeta = {};
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(componentFilePath));
    // get the relative path from the component file to the assets directory
    assetsDir = normalizePath(assetsDir.trim());
    if (config.sys.path.isAbsolute(assetsDir)) {
        // this path is absolute already!
        // add as the absolute path
        assetsMeta.absolutePath = assetsDir;
        // if this is an absolute path already, let's convert it to be relative
        assetsMeta.cmpRelativePath = config.sys.path.relative(componentDir, assetsDir);
    }
    else {
        // this path is relative to the component
        assetsMeta.cmpRelativePath = assetsDir;
        // create the absolute path to the asset dir
        assetsMeta.absolutePath = pathJoin(config, componentDir, assetsDir);
    }
    return assetsMeta;
}

function normalizeStyles(config, componentFilePath, stylesMeta) {
    const newStylesMeta = {};
    Object.keys(stylesMeta).forEach((modeName) => {
        newStylesMeta[modeName] = {
            externalStyles: []
        };
        const externalStyles = stylesMeta[modeName].externalStyles || [];
        newStylesMeta[modeName].externalStyles = externalStyles.map(externalStyle => {
            const { cmpRelativePath, absolutePath } = normalizeModeStylePaths(config, componentFilePath, externalStyle.originalComponentPath);
            const normalizedExternalStyles = {
                absolutePath: absolutePath,
                cmpRelativePath: cmpRelativePath,
                originalComponentPath: externalStyle.originalComponentPath,
                originalCollectionPath: externalStyle.originalCollectionPath
            };
            return normalizedExternalStyles;
        });
        if (typeof stylesMeta[modeName].styleStr === 'string') {
            newStylesMeta[modeName].styleStr = stylesMeta[modeName].styleStr;
        }
    });
    return newStylesMeta;
}
function normalizeModeStylePaths(config, componentFilePath, stylePath) {
    let cmpRelativePath;
    let absolutePath;
    // get the absolute path of the directory which the component is sitting in
    const componentDir = normalizePath(config.sys.path.dirname(componentFilePath));
    // get the relative path from the component file to the style
    let componentRelativeStylePath = normalizePath(stylePath.trim());
    if (config.sys.path.isAbsolute(componentRelativeStylePath)) {
        // this path is absolute already!
        // add to our list of style absolute paths
        absolutePath = componentRelativeStylePath;
        // if this is an absolute path already, let's convert it to be relative
        componentRelativeStylePath = config.sys.path.relative(componentDir, componentRelativeStylePath);
        // add to our list of style relative paths
        cmpRelativePath = componentRelativeStylePath;
    }
    else {
        // this path is relative to the component
        // add to our list of style relative paths
        cmpRelativePath = componentRelativeStylePath;
        // create the absolute path to the style file
        const absoluteStylePath = normalizePath(config.sys.path.join(componentDir, componentRelativeStylePath));
        // add to our list of style absolute paths
        absolutePath = absoluteStylePath;
    }
    return {
        cmpRelativePath,
        absolutePath
    };
}

function validateComponentClass(diagnostics, cmpMeta, classNode) {
    requiresReturnStatement(diagnostics, cmpMeta, classNode, 'hostData');
    requiresReturnStatement(diagnostics, cmpMeta, classNode, 'render');
}
function requiresReturnStatement(diagnostics, cmpMeta, classNode, methodName) {
    const classElm = classNode.members.find(m => isMethod(m, methodName));
    if (!classElm)
        return;
    let hasReturn = false;
    function visitNode(node) {
        if (node.kind === ts.SyntaxKind.ReturnStatement) {
            hasReturn = true;
        }
        ts.forEachChild(node, visitNode);
    }
    ts.forEachChild(classElm, visitNode);
    if (!hasReturn) {
        const diagnostic = buildWarn(diagnostics);
        diagnostic.messageText = `The "${methodName}()" method within the "${cmpMeta.tagNameMeta}" component is missing a "return" statement.`;
    }
}

function gatherMetadata(config, compilerCtx, buildCtx, typeChecker) {
    return (transformContext) => {
        function visit(node, tsSourceFile, moduleFile) {
            try {
                if (node.kind === ts.SyntaxKind.ImportDeclaration) {
                    getCollections(config, compilerCtx, buildCtx.collections, moduleFile, node);
                }
                if (ts.isClassDeclaration(node)) {
                    const cmpMeta = visitClass(config, buildCtx.diagnostics, typeChecker, node, tsSourceFile);
                    if (cmpMeta) {
                        if (moduleFile.cmpMeta) {
                            throw new Error(`More than one @Component() class in a single file is not valid`);
                        }
                        moduleFile.cmpMeta = cmpMeta;
                        cmpMeta.stylesMeta = normalizeStyles(config, moduleFile.sourceFilePath, cmpMeta.stylesMeta);
                        cmpMeta.assetsDirsMeta = normalizeAssetsDir(config, moduleFile.sourceFilePath, cmpMeta.assetsDirsMeta);
                    }
                }
                return node;
            }
            catch ({ message }) {
                const error = buildError(buildCtx.diagnostics);
                error.messageText = message;
                error.relFilePath = tsSourceFile.fileName;
            }
            return undefined;
        }
        return (tsSourceFile) => {
            const moduleFile = getModuleFile(compilerCtx, tsSourceFile.fileName);
            moduleFile.externalImports.length = 0;
            moduleFile.localImports.length = 0;
            moduleFile.cmpMeta = undefined;
            const results = ts.visitEachChild(tsSourceFile, (node) => {
                return visit(node, tsSourceFile, moduleFile);
            }, transformContext);
            if (moduleFile.cmpMeta) {
                const fileSymbol = typeChecker.getSymbolAtLocation(tsSourceFile);
                const fileExports = (fileSymbol && typeChecker.getExportsOfModule(fileSymbol)) || [];
                if (fileExports.length > 1) {
                    const warn = buildWarn(buildCtx.diagnostics);
                    warn.messageText = `@Component() should be the only export of the module.
Numerous export statements within a component module may cause undesirable bundling output, leading to unoptimized lazy loading.
Create a new auxiliary \`.ts\` file in order to export shared functionality.`;
                    warn.relFilePath = tsSourceFile.fileName;
                }
                if (fileExports.length === 0 ||
                    !isComponentClass$1(fileExports[0])) {
                    const error = buildError(buildCtx.diagnostics);
                    error.messageText = `Missing export in @Component() class`;
                    error.relFilePath = tsSourceFile.fileName;
                }
            }
            return results;
        };
    };
}
function isComponentClass$1(symbol) {
    const decorators = symbol.valueDeclaration && symbol.valueDeclaration.decorators;
    if (!decorators) {
        return false;
    }
    return isDecoratorNamed('Component')(decorators[0]);
}
function visitClass(config, diagnostics, typeChecker, classNode, sourceFile) {
    const cmpMeta = getComponentDecoratorMeta(diagnostics, typeChecker, classNode);
    if (!cmpMeta) {
        return null;
    }
    const componentClass = classNode.name.getText().trim();
    cmpMeta.componentClass = componentClass;
    cmpMeta.membersMeta = Object.assign({}, getElementDecoratorMeta(typeChecker, classNode), getMethodDecoratorMeta(config, diagnostics, typeChecker, classNode, sourceFile, componentClass), getStateDecoratorMeta(classNode), getPropDecoratorMeta(diagnostics, typeChecker, classNode, sourceFile, componentClass));
    cmpMeta.eventsMeta = getEventDecoratorMeta(diagnostics, typeChecker, classNode, sourceFile);
    cmpMeta.listenersMeta = getListenDecoratorMeta(typeChecker, classNode);
    // watch meta collection MUST happen after prop/state decorator meta collection
    getWatchDecoratorMeta(diagnostics, classNode, cmpMeta);
    // validate the user's component class for any common errors
    validateComponentClass(diagnostics, cmpMeta, classNode);
    // Return Class Declaration with Decorator removed and as default export
    return cmpMeta;
}

/**
 * Ok, so formatting overkill, we know. But whatever, it makes for great
 * error reporting within a terminal. So, yeah, let's code it up, shall we?
 */
function loadTypeScriptDiagnostics(config, resultsDiagnostics, tsDiagnostics) {
    const maxErrors = Math.min(tsDiagnostics.length, MAX_ERRORS);
    for (let i = 0; i < maxErrors; i++) {
        resultsDiagnostics.push(loadDiagnostic(config, tsDiagnostics[i]));
    }
}
function loadDiagnostic(config, tsDiagnostic) {
    const d = {
        level: 'warn',
        type: 'typescript',
        language: 'typescript',
        header: 'TypeScript',
        code: tsDiagnostic.code.toString(),
        messageText: formatMessageText(tsDiagnostic),
        relFilePath: null,
        absFilePath: null,
        lines: []
    };
    if (tsDiagnostic.category === ts.DiagnosticCategory.Error) {
        d.level = 'error';
    }
    if (tsDiagnostic.file) {
        d.absFilePath = normalizePath(tsDiagnostic.file.fileName);
        if (config) {
            d.relFilePath = normalizePath(config.sys.path.relative(config.cwd, d.absFilePath));
            if (!d.relFilePath.includes('/')) {
                d.relFilePath = './' + d.relFilePath;
            }
        }
        const sourceText = tsDiagnostic.file.text;
        const srcLines = splitLineBreaks(sourceText);
        const posData = tsDiagnostic.file.getLineAndCharacterOfPosition(tsDiagnostic.start);
        const errorLine = {
            lineIndex: posData.line,
            lineNumber: posData.line + 1,
            text: srcLines[posData.line],
            errorCharStart: posData.character,
            errorLength: Math.max(tsDiagnostic.length, 1)
        };
        d.lineNumber = errorLine.lineNumber;
        d.columnNumber = errorLine.errorCharStart;
        d.lines.push(errorLine);
        if (errorLine.errorLength === 0 && errorLine.errorCharStart > 0) {
            errorLine.errorLength = 1;
            errorLine.errorCharStart--;
        }
        if (errorLine.lineIndex > 0) {
            const previousLine = {
                lineIndex: errorLine.lineIndex - 1,
                lineNumber: errorLine.lineNumber - 1,
                text: srcLines[errorLine.lineIndex - 1],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.unshift(previousLine);
        }
        if (errorLine.lineIndex + 1 < srcLines.length) {
            const nextLine = {
                lineIndex: errorLine.lineIndex + 1,
                lineNumber: errorLine.lineNumber + 1,
                text: srcLines[errorLine.lineIndex + 1],
                errorCharStart: -1,
                errorLength: -1
            };
            d.lines.push(nextLine);
        }
    }
    return d;
}
function formatMessageText(tsDiagnostic) {
    let diagnosticChain = tsDiagnostic.messageText;
    if (typeof diagnosticChain === 'string') {
        return diagnosticChain;
    }
    const ignoreCodes = [];
    const isStencilConfig = tsDiagnostic.file.fileName.includes('stencil.config');
    if (isStencilConfig) {
        ignoreCodes.push(2322);
    }
    let result = '';
    while (diagnosticChain) {
        if (!ignoreCodes.includes(diagnosticChain.code)) {
            result += diagnosticChain.messageText + ' ';
        }
        diagnosticChain = diagnosticChain.next;
    }
    if (isStencilConfig) {
        result = result.replace(`type 'StencilConfig'`, `Stencil Config`);
        result = result.replace(`Object literal may only specify known properties, but `, ``);
        result = result.replace(`Object literal may only specify known properties, and `, ``);
    }
    return result.trim();
}

function removeCollectionImports(compilerCtx) {
    /*
  
      // remove side effect collection imports like:
      import 'ionicons';
  
      // do not remove collection imports with importClauses:
      import * as asdf 'ionicons';
      import { asdf } '@ionic/core';
  
    */
    return (transformContext) => {
        function visitImport(importNode) {
            if (!importNode.importClause && importNode.moduleSpecifier && ts.isStringLiteral(importNode.moduleSpecifier)) {
                // must not have an import clause
                // must have a module specifier and
                // the module specifier must be a string literal
                const moduleImport = importNode.moduleSpecifier.text;
                // test if this side effect import is a collection
                const isCollectionImport = compilerCtx.collections.some(c => {
                    return c.collectionName === moduleImport;
                });
                if (isCollectionImport) {
                    // turns out this is a side effect import is a collection,
                    // we actually don't want to include this in the JS output
                    // we've already gather the types we needed, kthxbai
                    return null;
                }
            }
            return importNode;
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

const CLASS_DECORATORS_TO_REMOVE = new Set(['Component']);
// same as the "declare" variables in the root index.ts file
const DECORATORS_TO_REMOVE = new Set([
    'Element',
    'Event',
    'Listen',
    'Method',
    'Prop',
    'PropDidChange',
    'PropWillChange',
    'State',
    'Watch'
]);
/**
 * Remove all decorators that are for metadata purposes
 */
function removeDecorators() {
    return (transformContext) => {
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    if (!isComponentClass(node)) {
                        return node;
                    }
                    return visitComponentClass(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => visit(tsSourceFile);
    };
}
/**
 * Visit the component class and remove decorators
 * @param classNode
 */
function visitComponentClass(classNode) {
    classNode.decorators = removeDecoratorsByName(classNode.decorators, CLASS_DECORATORS_TO_REMOVE);
    classNode.members.forEach((member) => {
        if (Array.isArray(member.decorators)) {
            member.decorators = removeDecoratorsByName(member.decorators, DECORATORS_TO_REMOVE);
        }
    });
    return classNode;
}
/**
 * Remove a decorator from the an array by name
 * @param decorators array of decorators
 * @param name name to remove
 */
function removeDecoratorsByName(decoratorList, names) {
    const updatedDecoratorList = decoratorList.filter(dec => {
        const toRemove = ts.isCallExpression(dec.expression) &&
            ts.isIdentifier(dec.expression.expression) &&
            names.has(dec.expression.expression.text);
        return !toRemove;
    });
    if (updatedDecoratorList.length === 0 && decoratorList.length > 0) {
        return undefined;
    }
    if (updatedDecoratorList.length !== decoratorList.length) {
        return ts.createNodeArray(updatedDecoratorList);
    }
    return decoratorList;
}

function removeStencilImports() {
    return (transformContext) => {
        function visitImport(importNode) {
            if (importNode.moduleSpecifier &&
                ts.isStringLiteral(importNode.moduleSpecifier) &&
                importNode.moduleSpecifier.text === '@stencil/core') {
                return null;
            }
            return importNode;
        }
        function visit(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    return visitImport(node);
                default:
                    return ts.visitEachChild(node, visit, transformContext);
            }
        }
        return (tsSourceFile) => {
            return visit(tsSourceFile);
        };
    };
}

/**
 * This is only used during TESTING
 */
function transpileModuleForTesting(config, options, sourceFilePath, input) {
    const compilerCtx = {
        collections: [],
        moduleFiles: {},
        resolvedCollections: [],
        events: {
            emit: noop,
            subscribe: noop,
            unsubscribe: noop,
            unsubscribeAll: noop
        }
    };
    const buildCtx = new BuildContext(config, compilerCtx);
    sourceFilePath = normalizePath(sourceFilePath);
    const results = {
        sourceFilePath: sourceFilePath,
        code: null,
        map: null,
        diagnostics: [],
        cmpMeta: null
    };
    options.sourceMap = true;
    options.isolatedModules = true;
    // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.
    options.suppressOutputPathCheck = true;
    // Filename can be non-ts file.
    options.allowNonTsExtensions = true;
    // We are not returning a sourceFile for lib file when asked by the program,
    // so pass --noLib to avoid reporting a file not found error.
    options.noLib = true;
    // Clear out other settings that would not be used in transpiling this module
    options.lib = undefined;
    options.types = undefined;
    options.noEmit = undefined;
    options.noEmitOnError = undefined;
    options.paths = undefined;
    options.rootDirs = undefined;
    options.declaration = undefined;
    options.declarationDir = undefined;
    options.out = undefined;
    options.outFile = undefined;
    // We are not doing a full typecheck, we are not resolving the whole context,
    // so pass --noResolve to avoid reporting missing file errors.
    options.noResolve = true;
    // if jsx is specified then treat file as .tsx
    const inputFileName = sourceFilePath || (options.jsx ? `module.tsx` : `module.ts`);
    const sourceFile = ts.createSourceFile(inputFileName, input, options.target);
    // Create a compilerHost object to allow the compiler to read and write files
    const compilerHost = {
        getSourceFile: (fileName) => fileName === normalizePath(inputFileName) ? sourceFile : undefined,
        writeFile: function (name, text) {
            if (name.endsWith('.map')) {
                results.map = text;
            }
            else {
                results.code = text;
            }
        },
        getDefaultLibFileName: () => `lib.d.ts`,
        useCaseSensitiveFileNames: () => false,
        getCanonicalFileName: (fileName) => fileName,
        getCurrentDirectory: () => '',
        getNewLine: () => ts.sys.newLine,
        fileExists: (fileName) => fileName === inputFileName,
        readFile: () => '',
        directoryExists: () => true,
        getDirectories: () => []
    };
    const program = ts.createProgram([inputFileName], options, compilerHost);
    const typeChecker = program.getTypeChecker();
    // Emit
    program.emit(undefined, undefined, undefined, false, {
        before: [
            gatherMetadata(config, compilerCtx, buildCtx, typeChecker),
            removeDecorators(),
            addComponentMetadata(compilerCtx.moduleFiles)
        ],
        after: [
            removeStencilImports(),
            removeCollectionImports(compilerCtx)
        ]
    });
    const tsDiagnostics = program.getOptionsDiagnostics().concat(program.getSyntacticDiagnostics());
    loadTypeScriptDiagnostics(config, buildCtx.diagnostics, tsDiagnostics);
    results.diagnostics.push(...buildCtx.diagnostics);
    const moduleFile = compilerCtx.moduleFiles[results.sourceFilePath];
    results.cmpMeta = moduleFile ? moduleFile.cmpMeta : null;
    return results;
}

class TestWindowLogger {
    constructor() {
        this.logs = [];
        this.buildLogFilePath = null;
    }
    printLogs() {
        this.logs.forEach(log => {
            console[log.level].apply(console, log.msgs);
        });
        this.logs.length = 0;
    }
    info(...msgs) {
        this.logs.push({
            level: 'info',
            msgs: msgs
        });
    }
    error(...msgs) {
        this.logs.push({
            level: 'error',
            msgs: msgs
        });
    }
    warn(...msgs) {
        this.logs.push({
            level: 'warn',
            msgs: msgs
        });
    }
    debug() { }
    createTimeSpan(_startMsg) {
        return {
            finish: () => { }
        };
    }
    printDiagnostics(_diagnostics) { }
    green(v) {
        return v;
    }
    yellow(v) {
        return v;
    }
    red(v) {
        return v;
    }
    blue(v) {
        return v;
    }
    magenta(v) {
        return v;
    }
    cyan(v) {
        return v;
    }
    gray(v) {
        return v;
    }
    bold(v) {
        return v;
    }
    dim(v) {
        return v;
    }
    writeLogs(_append) { }
}

const sys = mockStencilSystem();
function transpile(input, opts = {}, path$$1) {
    const results = { diagnostics: null, code: null, map: null };
    if (!opts.module) {
        opts.module = 'CommonJS';
    }
    const compilerOpts = Object.assign({}, opts);
    if (!path$$1) {
        path$$1 = '/tmp/transpile.tsx';
    }
    const logger = new TestWindowLogger();
    const config = validateConfig({
        sys: sys,
        logger: logger,
        cwd: process.cwd(),
        rootDir: '/',
        srcDir: '/',
        devMode: true,
        _isTesting: true,
        validateTypes: false
    });
    const transpileResults = transpileModuleForTesting(config, compilerOpts, path$$1, input);
    results.code = transpileResults.code;
    results.map = transpileResults.map;
    results.diagnostics = transpileResults.diagnostics;
    logger.printLogs();
    return results;
}

const jestPreprocessor = {
    process(sourceText, filePath) {
        if (filePath.endsWith('.d.ts')) {
            // .d.ts file doesn't need to be transpiled for testing
            return '';
        }
        if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) {
            const opts = {
                module: 'commonjs',
                target: 'es2015'
            };
            if (filePath.endsWith('.tsx')) {
                opts.jsx = ts.JsxEmit.React;
                opts.jsxFactory = 'h';
                opts.esModuleInterop = true;
            }
            const results = transpile(sourceText, opts, filePath);
            if (results.diagnostics && results.diagnostics.length > 0) {
                const msg = results.diagnostics.map(formatDiagnostics).join('\n\n');
                throw new Error(msg);
            }
            return {
                code: results.code,
                map: results.map
            };
        }
        return sourceText;
    }
};
function formatDiagnostics(diagnostic) {
    var m = '';
    if (diagnostic.relFilePath) {
        m += diagnostic.relFilePath;
        if (typeof diagnostic.lineNumber === 'number') {
            m += ':' + diagnostic.lineNumber + 1;
            if (typeof diagnostic.columnNumber === 'number') {
                m += ':' + diagnostic.columnNumber;
            }
        }
        m += '\n';
    }
    m += diagnostic.messageText;
    return m;
}

function toEqualAttribute(elm, expectAttrName, expectAttrValue) {
    if (!elm) {
        throw new Error(`expect toMatchAttribute value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toMatchAttribute value is not an element`);
    }
    let receivedAttrValue = elm.getAttribute(expectAttrName);
    if (expectAttrValue != null) {
        expectAttrValue = String(expectAttrValue);
    }
    if (receivedAttrValue != null) {
        receivedAttrValue = String(receivedAttrValue);
    }
    const pass = (expectAttrValue === receivedAttrValue);
    return {
        message: () => `expected attribute ${expectAttrName} "${expectAttrValue}" to ${pass ? 'not ' : ''}equal "${receivedAttrValue}"`,
        pass: pass,
    };
}
function toEqualAttributes(elm, expectAttrs) {
    if (!elm) {
        throw new Error(`expect toEqualAttributes value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toEqualAttributes value is not an element`);
    }
    const attrNames = Object.keys(expectAttrs);
    const pass = attrNames.every(attrName => {
        let expectAttrValue = expectAttrs[attrName];
        if (expectAttrValue != null) {
            expectAttrValue = String(expectAttrValue);
        }
        return elm.getAttribute(attrName) === expectAttrValue;
    });
    return {
        message: () => `expected attributes to ${pass ? 'not ' : ''}equal ${attrNames.map(a => `[${a}="${expectAttrs[a]}"]`).join(', ')}`,
        pass: pass,
    };
}
function toHaveAttribute(elm, expectAttrName) {
    if (!elm) {
        throw new Error(`expect toHaveAttribute value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1 /* ELEMENT_NODE */) {
        throw new Error(`expect toHaveAttribute value is not an element`);
    }
    const pass = elm.hasAttribute(expectAttrName);
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have the attribute "${expectAttrName}"`,
        pass: pass,
    };
}

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};

function toHaveReceivedEvent(eventSpy) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEvent event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEvent did not receive an event spy`);
    }
    const pass = (eventSpy.events.length > 0);
    return {
        message: () => `expected to have ${pass ? 'not ' : ''}called "${eventSpy.eventName}" event`,
        pass: pass,
    };
}
function toHaveReceivedEventTimes(eventSpy, count) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEventTimes event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEventTimes did not receive an event spy`);
    }
    const pass = (eventSpy.length === count);
    return {
        message: () => `expected event "${eventSpy.eventName}" to have been called ${count} times, but was called ${eventSpy.events.length} time${eventSpy.events.length > 1 ? 's' : ''}`,
        pass: pass,
    };
}
function toHaveReceivedEventDetail(eventSpy, eventDetail) {
    if (!eventSpy) {
        throw new Error(`toHaveReceivedEventDetail event spy is null`);
    }
    if (typeof eventSpy.then === 'function') {
        throw new Error(`event spy must be a resolved value, not a promise, before it can be tested`);
    }
    if (!eventSpy.eventName) {
        throw new Error(`toHaveReceivedEventDetail did not receive an event spy`);
    }
    if (!eventSpy.lastEvent) {
        throw new Error(`event "${eventSpy.eventName}" was not received`);
    }
    const pass = fastDeepEqual(eventSpy.lastEvent.detail, eventDetail);
    expect(eventSpy.lastEvent.detail).toEqual(eventDetail);
    return {
        message: () => `expected event "${eventSpy.eventName}" detail to ${pass ? 'not ' : ''}equal`,
        pass: pass,
    };
}

function toEqualHtml(input, shouldEqual) {
    if (input == null) {
        throw new Error(`expect toEqualHtml value is null`);
    }
    let serializeA;
    if (input.nodeType === 1 /* ELEMENT_NODE */) {
        serializeA = mockDoc.serializeNodeToHtml(input, {
            pretty: true,
            outerHTML: true
        });
    }
    else if (input.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
        serializeA = mockDoc.serializeNodeToHtml(input, {
            pretty: true,
            excludeTags: ['style'],
            excludeTagContent: ['style']
        });
    }
    else if (typeof input === 'string') {
        const parseA = mockDoc.parseHtmlToFragment(input);
        serializeA = mockDoc.serializeNodeToHtml(parseA, {
            pretty: true
        });
    }
    else {
        throw new Error(`expect toEqualHtml value should be an element, shadow root or string`);
    }
    const parseB = mockDoc.parseHtmlToFragment(shouldEqual);
    const serializeB = mockDoc.serializeNodeToHtml(parseB, {
        pretty: true
    });
    if (serializeA !== serializeB) {
        expect(serializeA).toBe(serializeB);
        return {
            message: () => 'HTML does not match',
            pass: false,
        };
    }
    return {
        message: () => 'expect HTML to match',
        pass: true,
    };
}

function toEqualText(input, expectTextContent) {
    if (!input) {
        throw new Error(`expect toEqualText value is null`);
    }
    if (typeof input.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    let textContent;
    if (input.nodeType === 1 /* ELEMENT_NODE */) {
        textContent = input.textContent.replace(/\s\s+/g, ' ').trim();
    }
    else if (input != null) {
        textContent = String(input).replace(/\s\s+/g, ' ').trim();
    }
    if (typeof expectTextContent === 'string') {
        expectTextContent = expectTextContent.replace(/\s\s+/g, ' ').trim();
    }
    const pass = (textContent === expectTextContent);
    return {
        message: () => `expected textContent "${expectTextContent}" to ${pass ? 'not ' : ''}equal "${textContent}"`,
        pass: pass,
    };
}

function toHaveClass(elm, expectClassName) {
    if (!elm) {
        throw new Error(`expect toHaveClass value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1) {
        throw new Error(`expect toHaveClass value is not an element`);
    }
    const pass = elm.classList.contains(expectClassName);
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have css class "${expectClassName}"`,
        pass: pass,
    };
}
function toHaveClasses(elm, expectClassNames) {
    if (!elm) {
        throw new Error(`expect toHaveClasses value is null`);
    }
    if (typeof elm.then === 'function') {
        throw new Error(`element must be a resolved value, not a promise, before it can be tested`);
    }
    if (elm.nodeType !== 1) {
        throw new Error(`expect toHaveClasses value is not an element`);
    }
    const pass = expectClassNames.every(expectClassName => {
        return elm.classList.contains(expectClassName);
    });
    return {
        message: () => `expected to ${pass ? 'not ' : ''}have css classes "${expectClassNames.join(' ')}", but className is "${elm.className}"`,
        pass: pass,
    };
}
function toMatchClasses(elm, expectClassNames) {
    let { pass } = toHaveClasses(elm, expectClassNames);
    if (pass) {
        pass = expectClassNames.length === elm.classList.length;
    }
    return {
        message: () => `expected to ${pass ? 'not ' : ''}match css classes "${expectClassNames.join(' ')}", but className is "${elm.className}"`,
        pass: pass,
    };
}

function toMatchScreenshot(compare, opts = {}) {
    if (!compare) {
        throw new Error(`expect toMatchScreenshot value is null`);
    }
    if (typeof compare.then === 'function') {
        throw new Error(`expect(compare).toMatchScreenshot() must be a resolved value, not a promise, before it can be tested`);
    }
    if (typeof compare.mismatchedPixels !== 'number') {
        throw new Error(`expect toMatchScreenshot() value is not a screenshot compare`);
    }
    const device = compare.device || compare.userAgent;
    if (typeof opts.allowableMismatchedRatio === 'number') {
        if (opts.allowableMismatchedRatio < 0 || opts.allowableMismatchedRatio > 1) {
            throw new Error(`expect toMatchScreenshot() allowableMismatchedRatio must be a value ranging from 0 to 1`);
        }
        return {
            message: () => `${device}: screenshot has a mismatch ratio of "${compare.mismatchedRatio}" for "${compare.desc}", but expected ratio to be less than "${opts.allowableMismatchedRatio}"`,
            pass: (compare.mismatchedRatio <= opts.allowableMismatchedRatio),
        };
    }
    if (typeof opts.allowableMismatchedPixels === 'number') {
        if (opts.allowableMismatchedPixels < 0) {
            throw new Error(`expect toMatchScreenshot() allowableMismatchedPixels value must be a value that is 0 or greater`);
        }
        return {
            message: () => `${device}: screenshot has "${compare.mismatchedPixels}" mismatched pixels for "${compare.desc}", but expected less than "${opts.allowableMismatchedPixels}" mismatched pixels`,
            pass: (compare.mismatchedPixels <= opts.allowableMismatchedPixels),
        };
    }
    if (typeof compare.allowableMismatchedRatio === 'number') {
        return {
            message: () => `${device}: screenshot has a mismatch ratio of "${compare.mismatchedRatio}" for "${compare.desc}", but expected ratio to be less than "${compare.allowableMismatchedRatio}"`,
            pass: (compare.mismatchedRatio <= compare.allowableMismatchedRatio),
        };
    }
    if (typeof compare.allowableMismatchedPixels === 'number') {
        return {
            message: () => `${device}: screenshot has "${compare.mismatchedPixels}" mismatched pixels for "${compare.desc}", but expected less than "${compare.allowableMismatchedPixels}" mismatched pixels`,
            pass: (compare.mismatchedPixels <= compare.allowableMismatchedPixels),
        };
    }
    throw new Error(`expect toMatchScreenshot() missing allowableMismatchedPixels in testing config`);
}

const expectExtend = {
    toEqualAttribute,
    toEqualAttributes,
    toEqualHtml,
    toEqualText,
    toHaveAttribute,
    toHaveClass,
    toHaveClasses,
    toMatchClasses,
    toHaveReceivedEvent,
    toHaveReceivedEventDetail,
    toHaveReceivedEventTimes,
    toMatchScreenshot
};

function getDefaultBuildConditionals() {
    return {
        coreId: 'core',
        polyfills: false,
        cssVarShim: true,
        shadowDom: true,
        slotPolyfill: true,
        ssrServerSide: true,
        devInspector: true,
        hotModuleReplacement: true,
        verboseError: true,
        styles: true,
        hostData: true,
        hostTheme: true,
        reflectToAttr: true,
        hasSlot: true,
        hasSvg: true,
        observeAttr: true,
        isDev: true,
        isProd: false,
        element: true,
        event: true,
        listener: true,
        method: true,
        propConnect: true,
        propContext: true,
        watchCallback: true,
        cmpDidLoad: true,
        cmpWillLoad: true,
        cmpDidUpdate: true,
        cmpWillUpdate: true,
        cmpDidUnload: true,
        clientSide: false,
        externalModuleLoader: false,
        browserModuleLoader: false,
        es5: false
    };
}

var _btoa;

if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
	_btoa = window.btoa;
} else if ( typeof Buffer === 'function' ) {
	_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
} else {
	_btoa = function () {
		throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
	};
}

// Adapted to TS from https://github.com/rollup/rollup-plugin-replace

function jestSetupTestFramework() {
    global.__BUILD_CONDITIONALS__ = getDefaultBuildConditionals();
    global.Context = {};
    global.h = h;
    global.resourcesUrl = '/build';
    mockDoc.applyWindowToGlobal(global);
    expect.extend(expectExtend);
    const jasmineEnv = jasmine.getEnv();
    if (jasmineEnv) {
        jasmineEnv.addReporter({
            specStarted: (spec) => {
                global.currentSpec = spec;
            }
        });
    }
    global.screenshotDescriptions = new Set();
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 15000;
}

function initPageEvents(page) {
    return __awaiter(this, void 0, void 0, function* () {
        page._events = [];
        page._eventIds = 0;
        yield page.exposeFunction('stencilOnEvent', (browserEvent) => {
            // NODE CONTEXT
            nodeContextEvents(page._events, browserEvent);
        });
        yield page.evaluateOnNewDocument(browserContextEvents);
        page.spyOnEvent = pageSpyOnEvent.bind(page, page);
    });
}
function pageSpyOnEvent(page, eventName, selector) {
    return __awaiter(this, void 0, void 0, function* () {
        const eventSpy = new EventSpy(eventName);
        if (selector !== 'document') {
            selector = 'window';
        }
        const handle = yield page.evaluateHandle(selector);
        yield addE2EListener(page, handle, eventName, (ev) => {
            eventSpy.events.push(ev);
        });
        return eventSpy;
    });
}
class EventSpy {
    constructor(eventName) {
        this.eventName = eventName;
        this.events = [];
    }
    get length() {
        return this.events.length;
    }
    get firstEvent() {
        return this.events[0] || null;
    }
    get lastEvent() {
        return this.events[this.events.length - 1] || null;
    }
}
function addE2EListener(page, elmHandle, eventName, resolve, cancelRejectId) {
    return __awaiter(this, void 0, void 0, function* () {
        // NODE CONTEXT
        const id = page._eventIds++;
        page._events.push({
            id: id,
            eventName: eventName,
            resolve: resolve,
            cancelRejectId: cancelRejectId
        });
        const executionContext = elmHandle.executionContext();
        // add element event listener
        yield executionContext.evaluate((elm, id, eventName) => {
            elm.addEventListener(eventName, (ev) => {
                window.stencilOnEvent({
                    id: id,
                    event: window.stencilSerializeEvent(ev)
                });
            });
        }, elmHandle, id, eventName);
    });
}
function nodeContextEvents(waitForEvents, browserEvent) {
    // NODE CONTEXT
    const waitForEventData = waitForEvents.find(waitData => {
        return waitData.id === browserEvent.id;
    });
    if (waitForEventData) {
        if (waitForEventData.cancelRejectId != null) {
            clearTimeout(waitForEventData.cancelRejectId);
        }
        waitForEventData.resolve(browserEvent.event);
    }
}
function browserContextEvents() {
    // BROWSER CONTEXT
    window.addEventListener('appload', () => {
        // BROWSER CONTEXT
        window.stencilAppLoaded = true;
    });
    window.stencilSerializeEventTarget = (target) => {
        // BROWSER CONTEXT
        if (!target) {
            return null;
        }
        if (target === window) {
            return { serializedWindow: true };
        }
        if (target === document) {
            return { serializedDocument: true };
        }
        if (target.nodeType != null) {
            const serializedElement = {
                serializedElement: true,
                nodeName: target.nodeName,
                nodeValue: target.nodeValue,
                nodeType: target.nodeType,
                tagName: target.tagName,
                className: target.className,
                id: target.id,
            };
            return serializedElement;
        }
        return null;
    };
    window.stencilSerializeEvent = (orgEv) => {
        // BROWSER CONTEXT
        const serializedEvent = {
            bubbles: orgEv.bubbles,
            cancelBubble: orgEv.cancelBubble,
            cancelable: orgEv.cancelable,
            composed: orgEv.composed,
            currentTarget: window.stencilSerializeEventTarget(orgEv.currentTarget),
            defaultPrevented: orgEv.defaultPrevented,
            detail: orgEv.detail,
            eventPhase: orgEv.eventPhase,
            isTrusted: orgEv.isTrusted,
            returnValue: orgEv.returnValue,
            srcElement: window.stencilSerializeEventTarget(orgEv.srcElement),
            target: window.stencilSerializeEventTarget(orgEv.target),
            timeStamp: orgEv.timeStamp,
            type: orgEv.type,
            isSerializedEvent: true
        };
        return serializedEvent;
    };
}

class E2EElement extends mockDoc.MockElement {
    constructor(_page, _elmHandle) {
        super(null, null);
        this._page = _page;
        this._elmHandle = _elmHandle;
        this._queuedActions = [];
        this._shadowRoot = null;
        _page._elements.push(this);
    }
    find(selector) {
        return find(this._page, this._elmHandle, selector);
    }
    findAll(selector) {
        return findAll(this._page, this._elmHandle, selector);
    }
    callMethod(methodName, ...methodArgs) {
        this._queuedActions.push({
            methodName: methodName,
            methodArgs: methodArgs
        });
        return this.e2eRunActions();
    }
    triggerEvent(eventName, eventInitDict) {
        this._queuedActions.push({
            eventName: eventName,
            eventInitDict: eventInitDict
        });
    }
    spyOnEvent(eventName) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventSpy = new EventSpy(eventName);
            yield addE2EListener(this._page, this._elmHandle, eventName, (ev) => {
                eventSpy.events.push(ev);
            });
            return eventSpy;
        });
    }
    click(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.click(options);
            yield this._page.waitForChanges();
        });
    }
    focus() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.focus();
            yield this._page.waitForChanges();
        });
    }
    hover() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.hover();
            yield this._page.waitForChanges();
        });
    }
    isVisible() {
        return __awaiter(this, void 0, void 0, function* () {
            this._validate();
            let isVisible = false;
            try {
                const executionContext = this._elmHandle.executionContext();
                isVisible = yield executionContext.evaluate((elm) => {
                    return new Promise(resolve => {
                        window.requestAnimationFrame(() => {
                            if (elm.isConnected) {
                                const style = window.getComputedStyle(elm);
                                const isVisible = !!style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
                                resolve(isVisible);
                            }
                            else {
                                resolve(false);
                            }
                        });
                    });
                }, this._elmHandle);
            }
            catch (e) { }
            return isVisible;
        });
    }
    waitForVisible() {
        return new Promise((resolve, reject) => {
            let resolveTmr;
            const rejectTmr = setTimeout(() => {
                clearTimeout(resolveTmr);
                reject(`waitForVisible timed out`);
            }, 15000);
            const checkVisible = () => __awaiter(this, void 0, void 0, function* () {
                const isVisible = yield this.isVisible();
                if (isVisible) {
                    clearTimeout(rejectTmr);
                    resolve();
                }
                else {
                    resolveTmr = setTimeout(checkVisible, 10);
                }
            });
            checkVisible();
        });
    }
    waitForNotVisible() {
        return new Promise((resolve, reject) => {
            let resolveTmr;
            const rejectTmr = setTimeout(() => {
                clearTimeout(resolveTmr);
                reject(`waitForNotVisible timed out`);
            }, 15000);
            const checkVisible = () => __awaiter(this, void 0, void 0, function* () {
                const isVisible = yield this.isVisible();
                if (isVisible) {
                    resolveTmr = setTimeout(checkVisible, 10);
                }
                else {
                    clearTimeout(rejectTmr);
                    resolve();
                }
            });
            checkVisible();
        });
    }
    isIntersectingViewport() {
        return this._elmHandle.isIntersectingViewport();
    }
    press(key, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.press(key, options);
            yield this._page.waitForChanges();
        });
    }
    tap() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.tap();
            yield this._page.waitForChanges();
        });
    }
    type(text, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._elmHandle.type(text, options);
            yield this._page.waitForChanges();
        });
    }
    getProperty(propertyName) {
        return __awaiter(this, void 0, void 0, function* () {
            this._validate();
            const executionContext = this._elmHandle.executionContext();
            const propValue = yield executionContext.evaluate((elm, propertyName) => {
                return elm[propertyName];
            }, this._elmHandle, propertyName);
            return propValue;
        });
    }
    setProperty(propertyName, value) {
        this._queuedActions.push({
            setPropertyName: propertyName,
            setPropertyValue: value
        });
    }
    getAttribute(name) {
        this._validate();
        return super.getAttribute(name);
    }
    setAttribute(name, value) {
        this._queuedActions.push({
            setAttributeName: name,
            setAttributeValue: value
        });
    }
    get classList() {
        const api = {
            add: (...classNames) => {
                classNames.forEach(className => {
                    this._queuedActions.push({
                        classAdd: className
                    });
                });
            },
            remove: (...classNames) => {
                classNames.forEach(className => {
                    this._queuedActions.push({
                        classRemove: className
                    });
                });
            },
            toggle: (className) => {
                this._queuedActions.push({
                    classToggle: className
                });
            },
            contains: (className) => {
                this._validate();
                return this.className.split(' ').includes(className);
            }
        };
        return api;
    }
    get className() {
        this._validate();
        return super.className;
    }
    set className(value) {
        this._queuedActions.push({
            setPropertyName: 'className',
            setPropertyValue: value
        });
    }
    get id() {
        this._validate();
        return super.id;
    }
    set id(value) {
        this._queuedActions.push({
            setPropertyName: 'id',
            setPropertyValue: value
        });
    }
    get innerHTML() {
        this._validate();
        return super.innerHTML;
    }
    set innerHTML(value) {
        this._queuedActions.push({
            setPropertyName: 'innerHTML',
            setPropertyValue: value
        });
    }
    get innerText() {
        this._validate();
        return super.innerText;
    }
    set innerText(value) {
        this._queuedActions.push({
            setPropertyName: 'innerText',
            setPropertyValue: value
        });
    }
    get nodeValue() {
        this._validate();
        return super.nodeValue;
    }
    set nodeValue(value) {
        this._queuedActions.push({
            setPropertyName: 'nodeValue',
            setPropertyValue: value
        });
    }
    get outerHTML() {
        this._validate();
        return super.outerHTML;
    }
    set outerHTML(_) {
        throw new Error(`outerHTML is read-only`);
    }
    get shadowRoot() {
        this._validate();
        return this._shadowRoot;
    }
    set shadowRoot(_) {
        throw new Error(`shadowRoot is read-only`);
    }
    get tabIndex() {
        this._validate();
        return super.tabIndex;
    }
    set tabIndex(value) {
        this._queuedActions.push({
            setPropertyName: 'tabIndex',
            setPropertyValue: value
        });
    }
    get textContent() {
        this._validate();
        return super.textContent;
    }
    set textContent(value) {
        this._queuedActions.push({
            setPropertyName: 'textContent',
            setPropertyValue: value
        });
    }
    get title() {
        this._validate();
        return super.title;
    }
    set title(value) {
        this._queuedActions.push({
            setPropertyName: 'title',
            setPropertyValue: value
        });
    }
    getComputedStyle(pseudoElt) {
        return __awaiter(this, void 0, void 0, function* () {
            const style = yield this._page.evaluate((elm, pseudoElt) => {
                const rtn = {};
                const computedStyle = window.getComputedStyle(elm, pseudoElt);
                const keys = Object.keys(computedStyle);
                keys.forEach(key => {
                    if (isNaN(key)) {
                        const value = computedStyle[key];
                        if (value != null) {
                            rtn[key] = value;
                        }
                    }
                    else {
                        const dashProp = computedStyle[key];
                        if (dashProp.includes('-')) {
                            const value = computedStyle.getPropertyValue(dashProp);
                            if (value != null) {
                                rtn[dashProp] = value;
                            }
                        }
                    }
                });
                return rtn;
            }, this._elmHandle, pseudoElt);
            style.getPropertyValue = (propName) => {
                return style[propName];
            };
            return style;
        });
    }
    e2eRunActions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._queuedActions.length === 0) {
                return;
            }
            const executionContext = this._elmHandle.executionContext();
            const rtn = yield executionContext.evaluate((elm, queuedActions) => {
                // BROWSER CONTEXT
                // cannot use async/await in here cuz typescript transpiles it in the node context
                return elm.componentOnReady().then(() => {
                    let rtn = null;
                    queuedActions.forEach(queuedAction => {
                        if (queuedAction.methodName) {
                            rtn = elm[queuedAction.methodName].apply(elm, queuedAction.methodArgs);
                        }
                        else if (queuedAction.setPropertyName) {
                            elm[queuedAction.setPropertyName] = queuedAction.setPropertyValue;
                        }
                        else if (queuedAction.setAttributeName) {
                            elm.setAttribute(queuedAction.setAttributeName, queuedAction.setAttributeValue);
                        }
                        else if (queuedAction.classAdd) {
                            elm.classList.add(queuedAction.classAdd);
                        }
                        else if (queuedAction.classRemove) {
                            elm.classList.remove(queuedAction.classRemove);
                        }
                        else if (queuedAction.classToggle) {
                            elm.classList.toggle(queuedAction.classToggle);
                        }
                        else if (queuedAction.eventName) {
                            const eventInitDict = queuedAction.eventInitDict || {};
                            if (typeof eventInitDict.bubbles !== 'boolean') {
                                eventInitDict.bubbles = true;
                            }
                            if (typeof eventInitDict.cancelable !== 'boolean') {
                                eventInitDict.cancelable = true;
                            }
                            if (typeof eventInitDict.composed !== 'boolean') {
                                eventInitDict.composed = true;
                            }
                            const ev = new CustomEvent(queuedAction.eventName, eventInitDict);
                            elm.dispatchEvent(ev);
                        }
                    });
                    if (rtn && typeof rtn.then === 'function') {
                        return rtn.then((value) => {
                            return value;
                        });
                    }
                    return rtn;
                });
            }, this._elmHandle, this._queuedActions);
            this._queuedActions.length = 0;
            return rtn;
        });
    }
    e2eSync() {
        return __awaiter(this, void 0, void 0, function* () {
            const executionContext = this._elmHandle.executionContext();
            const { outerHTML, shadowRootHTML } = yield executionContext.evaluate((elm) => {
                return {
                    outerHTML: elm.outerHTML,
                    shadowRootHTML: elm.shadowRoot ? elm.shadowRoot.innerHTML : null
                };
            }, this._elmHandle);
            if (shadowRootHTML) {
                this._shadowRoot = mockDoc.parseHtmlToFragment(shadowRootHTML);
                this._shadowRoot.host = this;
            }
            else {
                this._shadowRoot = null;
            }
            const frag = mockDoc.parseHtmlToFragment(outerHTML);
            const rootElm = frag.firstElementChild;
            this.nodeName = rootElm.nodeName;
            this.attributes = rootElm.attributes.cloneAttributes();
            for (let i = this.childNodes.length - 1; i >= 0; i--) {
                this.removeChild(this.childNodes[i]);
            }
            while (rootElm.childNodes.length > 0) {
                this.appendChild(rootElm.childNodes[0]);
            }
        });
    }
    _validate() {
        if (this._queuedActions.length > 0) {
            throw new Error(`await page.waitForChanges() must be called before reading element information`);
        }
    }
    e2eDispose() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._elmHandle) {
                yield this._elmHandle.dispose();
                this._elmHandle = null;
            }
            const index = this._page._elements.indexOf(this);
            if (index > -1) {
                this._page._elements.splice(index, 1);
            }
            this._page = null;
        });
    }
}

function find(page, rootHandle, selector) {
    return __awaiter(this, void 0, void 0, function* () {
        const { lightSelector, shadowSelector, text, contains } = getSelector(selector);
        let elmHandle;
        if (typeof lightSelector === 'string') {
            elmHandle = yield findWithCssSelector(page, rootHandle, lightSelector, shadowSelector);
        }
        else {
            elmHandle = yield findWithText(page, rootHandle, text, contains);
        }
        if (!elmHandle) {
            return null;
        }
        const elm = new E2EElement(page, elmHandle);
        yield elm.e2eSync();
        return elm;
    });
}
function findWithCssSelector(page, rootHandle, lightSelector, shadowSelector) {
    return __awaiter(this, void 0, void 0, function* () {
        let elmHandle = yield rootHandle.$(lightSelector);
        if (!elmHandle) {
            return null;
        }
        if (shadowSelector) {
            const shadowHandle = yield page.evaluateHandle((elm, shadowSelector) => {
                if (!elm.shadowRoot) {
                    throw new Error(`shadow root does not exist for element: ${elm.tagName.toLowerCase()}`);
                }
                return elm.shadowRoot.querySelector(shadowSelector);
            }, elmHandle, shadowSelector);
            yield elmHandle.dispose();
            if (!shadowHandle) {
                return null;
            }
            elmHandle = shadowHandle.asElement();
        }
        return elmHandle;
    });
}
function findWithText(page, rootHandle, text, contains) {
    return __awaiter(this, void 0, void 0, function* () {
        const jsHandle = yield page.evaluateHandle((rootElm, text, contains) => {
            let foundElm = null;
            function checkContent(elm) {
                if (!elm || foundElm) {
                    return;
                }
                if (elm.nodeType === 3) {
                    if (typeof text === 'string' && elm.textContent.trim() === text) {
                        foundElm = elm.parentElement;
                        return;
                    }
                    if (typeof contains === 'string' && elm.textContent.includes(contains)) {
                        foundElm = elm.parentElement;
                        return;
                    }
                }
                checkContent(elm.shadowRoot);
                if (elm.childNodes) {
                    for (let i = 0; i < elm.childNodes.length; i++) {
                        checkContent(elm.childNodes[i]);
                    }
                }
            }
            checkContent(rootElm);
            return foundElm;
        }, rootHandle, text, contains);
        if (jsHandle) {
            return jsHandle.asElement();
        }
        return null;
    });
}
function findAll(page, rootHandle, selector) {
    return __awaiter(this, void 0, void 0, function* () {
        const foundElms = [];
        const { lightSelector, shadowSelector } = getSelector(selector);
        const lightElmHandles = yield rootHandle.$$(lightSelector);
        if (lightElmHandles.length === 0) {
            return foundElms;
        }
        if (shadowSelector) {
            // light dom selected, then shadow dom selected inside of light dom elements
            for (let i = 0; i < lightElmHandles.length; i++) {
                const executionContext = lightElmHandles[i].executionContext();
                const shadowJsHandle = yield executionContext.evaluateHandle((elm, shadowSelector) => {
                    if (!elm.shadowRoot) {
                        throw new Error(`shadow root does not exist for element: ${elm.tagName.toLowerCase()}`);
                    }
                    return elm.shadowRoot.querySelectorAll(shadowSelector);
                }, lightElmHandles[i], shadowSelector);
                yield lightElmHandles[i].dispose();
                const shadowJsProperties = yield shadowJsHandle.getProperties();
                yield shadowJsHandle.dispose();
                for (const shadowJsProperty of shadowJsProperties.values()) {
                    const shadowElmHandle = shadowJsProperty.asElement();
                    if (shadowElmHandle) {
                        const elm = new E2EElement(page, shadowElmHandle);
                        yield elm.e2eSync();
                        foundElms.push(elm);
                    }
                }
            }
        }
        else {
            // light dom only
            for (let i = 0; i < lightElmHandles.length; i++) {
                const elm = new E2EElement(page, lightElmHandles[i]);
                yield elm.e2eSync();
                foundElms.push(elm);
            }
        }
        return foundElms;
    });
}
function getSelector(selector) {
    const rtn = {
        lightSelector: null,
        shadowSelector: null,
        text: null,
        contains: null
    };
    if (typeof selector === 'string') {
        const splt = selector.split('>>>');
        rtn.lightSelector = splt[0].trim();
        rtn.shadowSelector = (splt.length > 1 ? splt[1].trim() : null);
    }
    else if (typeof selector.text === 'string') {
        rtn.text = selector.text.trim();
    }
    else if (typeof selector.contains === 'string') {
        rtn.contains = selector.contains.trim();
    }
    else {
        throw new Error(`invalid find selector: ${selector}`);
    }
    return rtn;
}

function writeScreenshotImage(imagePath, screenshotBuf) {
    return __awaiter(this, void 0, void 0, function* () {
        const imageExists = yield fileExists(imagePath);
        if (!imageExists) {
            yield writeFile(imagePath, screenshotBuf);
        }
    });
}
function writeScreenshotData(dataDir, screenshotData) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = getDataFilePath(dataDir, screenshotData.id);
        const content = JSON.stringify(screenshotData, null, 2);
        yield writeFile(filePath, content);
    });
}
function readScreenshotData(dataDir, screenshotId) {
    return __awaiter(this, void 0, void 0, function* () {
        let rtn = null;
        try {
            const dataFilePath = getDataFilePath(dataDir, screenshotId);
            const dataContent = yield readFile(dataFilePath);
            rtn = JSON.parse(dataContent);
        }
        catch (e) { }
        return rtn;
    });
}
function getDataFilePath(dataDir, screenshotId) {
    const fileName = `${screenshotId}.json`;
    return path.join(dataDir, fileName);
}
function fileExists(filePath) {
    return new Promise(resolve => {
        fs.access(filePath, (err) => resolve(!err));
    });
}
function readFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf-8', (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
function writeFile(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}

function getMismatchedPixels(cacheDir, imageDir, masterImageName, localImageName, width, height, pixelmatchThreshold) {
    return __awaiter(this, void 0, void 0, function* () {
        const cacheKey = getCacheKey(masterImageName, localImageName, width, height, pixelmatchThreshold);
        const diffJsonPath = path__default.join(cacheDir, `mismatch_${cacheKey}.json.log`);
        try {
            const diffData = JSON.parse(yield readFile(diffJsonPath));
            if (diffData && typeof diffData.mismatch === 'number') {
                return diffData.mismatch;
            }
        }
        catch (e) { }
        const images = yield Promise.all([
            readImage(imageDir, masterImageName),
            readImage(imageDir, localImageName)
        ]);
        const pixelmatch = require('pixelmatch');
        const mismatchedPixels = pixelmatch(images[0], images[1], null, width, height, {
            threshold: pixelmatchThreshold,
            includeAA: false
        });
        const diffData = {
            mismatch: mismatchedPixels
        };
        try {
            yield writeFile(diffJsonPath, JSON.stringify(diffData));
        }
        catch (e) { }
        return diffData.mismatch;
    });
}
function getCacheKey(masterImageName, localImageName, width, height, pixelmatchThreshold) {
    const hash = crypto.createHash('md5');
    hash.update(masterImageName);
    hash.update(localImageName);
    hash.update(width.toString());
    hash.update(height.toString());
    hash.update(pixelmatchThreshold.toString());
    return hash.digest('hex').toLowerCase();
}
function readImage(imagesDir, image) {
    return new Promise(resolve => {
        const { PNG } = require('pngjs');
        const filePath = path__default.join(imagesDir, image);
        const rs = fs__default.createReadStream(filePath);
        rs.pipe(new PNG()).on('parsed', resolve);
    });
}

function compareScreenshot(emulateConfig, screenshotBuildData, screenshotBuf, desc, testPath, pixelmatchThreshold) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = crypto.createHash('md5').update(screenshotBuf).digest('hex');
        const localImageName = `${hash}.png`;
        const imagePath = path__default.join(screenshotBuildData.imagesDirPath, localImageName);
        if (testPath) {
            testPath = normalizePath(path__default.relative(screenshotBuildData.rootDir, testPath));
        }
        // create the data we'll be saving as json
        // the "id" is what we use as a key to compare to sets of data
        // the "image" is a hash of the image file name
        // and what we can use to quickly see if they're identical or not
        const localData = {
            id: getScreenshotId(emulateConfig, desc),
            image: localImageName,
            device: emulateConfig.device,
            userAgent: emulateConfig.userAgent,
            desc: desc,
            testPath: testPath,
            width: emulateConfig.width,
            height: emulateConfig.height,
            deviceScaleFactor: emulateConfig.deviceScaleFactor,
            naturalWidth: Math.round(emulateConfig.width * emulateConfig.deviceScaleFactor),
            naturalHeight: Math.round(emulateConfig.height * emulateConfig.deviceScaleFactor),
            hasTouch: emulateConfig.hasTouch,
            isLandscape: emulateConfig.isLandscape,
            isMobile: emulateConfig.isMobile,
            mediaType: emulateConfig.mediaType
        };
        // write the local build data
        yield Promise.all([
            writeScreenshotData(screenshotBuildData.localDirPath, localData),
            writeScreenshotImage(imagePath, screenshotBuf)
        ]);
        // this is the data that'll get used by the jest matcher
        const compare = {
            id: localData.id,
            desc: localData.desc,
            expectedImage: null,
            receivedImage: localData.image,
            mismatchedPixels: 0,
            mismatchedRatio: 0,
            device: emulateConfig.device,
            userAgent: emulateConfig.userAgent,
            width: emulateConfig.width,
            height: emulateConfig.height,
            deviceScaleFactor: emulateConfig.deviceScaleFactor,
            naturalWidth: localData.naturalWidth,
            naturalHeight: localData.naturalHeight,
            hasTouch: emulateConfig.hasTouch,
            isLandscape: emulateConfig.isLandscape,
            isMobile: emulateConfig.isMobile,
            mediaType: emulateConfig.mediaType,
            allowableMismatchedPixels: screenshotBuildData.allowableMismatchedPixels,
            allowableMismatchedRatio: screenshotBuildData.allowableMismatchedRatio,
            testPath: testPath
        };
        if (screenshotBuildData.updateMaster) {
            // this data is going to become the master data
            // so no need to compare with previous versions
            yield writeScreenshotData(screenshotBuildData.masterDirPath, localData);
            return compare;
        }
        const masterData = yield readScreenshotData(screenshotBuildData.masterDirPath, localData.id);
        if (!masterData) {
            // there is no master data so nothing to compare it with
            yield writeScreenshotData(screenshotBuildData.masterDirPath, localData);
            return compare;
        }
        // set that the master data image is the image we're expecting
        compare.expectedImage = masterData.image;
        // compare only if the image hashes are different
        if (compare.expectedImage !== compare.receivedImage) {
            // compare the two images pixel by pixel to
            // figure out a mismatch value
            compare.mismatchedPixels = yield getMismatchedPixels(screenshotBuildData.cacheDir, screenshotBuildData.imagesDirPath, compare.expectedImage, compare.receivedImage, compare.naturalWidth, compare.naturalHeight, pixelmatchThreshold);
        }
        compare.mismatchedRatio = (compare.mismatchedPixels / (compare.naturalWidth * compare.naturalHeight));
        return compare;
    });
}
function getScreenshotId(emulateConfig, uniqueDescription) {
    if (typeof uniqueDescription !== 'string' || uniqueDescription.trim().length === 0) {
        throw new Error(`invalid test description`);
    }
    const hash = crypto.createHash('md5');
    hash.update(uniqueDescription);
    hash.update(emulateConfig.width.toString());
    hash.update(emulateConfig.height.toString());
    hash.update(emulateConfig.deviceScaleFactor.toString());
    hash.update(emulateConfig.userAgent.toString());
    hash.update(emulateConfig.hasTouch.toString());
    hash.update(emulateConfig.isMobile.toString());
    if (emulateConfig.mediaType != null) {
        hash.update(emulateConfig.mediaType);
    }
    return hash.digest('hex').substr(0, 8).toLowerCase();
}

function initPageScreenshot(page) {
    const env = (process.env);
    if (env.__STENCIL_SCREENSHOT__ === 'true') {
        page.compareScreenshot = (a, b) => {
            const jestEnv = global;
            let desc = '';
            let testPath = '';
            if (jestEnv.currentSpec) {
                if (typeof jestEnv.currentSpec.fullName === 'string') {
                    desc = jestEnv.currentSpec.fullName;
                }
                if (typeof jestEnv.currentSpec.testPath === 'string') {
                    testPath = jestEnv.currentSpec.testPath;
                }
            }
            let opts;
            if (typeof a === 'string') {
                if (desc.length > 0) {
                    desc += ', ' + a;
                }
                else {
                    desc = a;
                }
                if (typeof b === 'object') {
                    opts = b;
                }
            }
            else if (typeof a === 'object') {
                opts = a;
            }
            desc = desc.trim();
            opts = opts || {};
            if (!desc) {
                throw new Error(`Invalid screenshot description in "${testPath}"`);
            }
            if (jestEnv.screenshotDescriptions.has(desc)) {
                throw new Error(`Screenshot description "${desc}" found in "${testPath}" cannot be used for multiple screenshots and must be unique. To make screenshot descriptions unique within the same test, use the first argument to "compareScreenshot", such as "compareScreenshot('more to the description')".`);
            }
            jestEnv.screenshotDescriptions.add(desc);
            return pageCompareScreenshot(page, env, desc, testPath, opts);
        };
    }
    else {
        // screen shot not enabled, so just skip over all the logic
        page.compareScreenshot = () => __awaiter(this, void 0, void 0, function* () {
            const compare = {
                mismatchedRatio: 0,
                mismatchedPixels: 0,
                allowableMismatchedPixels: 1,
                allowableMismatchedRatio: 1.0,
                desc: ''
            };
            return compare;
        });
    }
}
function pageCompareScreenshot(page, env, desc, testPath, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof env.__STENCIL_EMULATE__ !== 'string') {
            throw new Error(`compareScreenshot, missing screenshot emulate env var`);
        }
        if (typeof env.__STENCIL_SCREENSHOT_BUILD__ !== 'string') {
            throw new Error(`compareScreenshot, missing screen build env var`);
        }
        const emulateConfig = JSON.parse(env.__STENCIL_EMULATE__);
        const screenshotBuildData = JSON.parse(env.__STENCIL_SCREENSHOT_BUILD__);
        const screenshotOpts = createPuppeteerScreenshopOptions(opts);
        const screenshotBuf = yield page.screenshot(screenshotOpts);
        const pixelmatchThreshold = (typeof opts.pixelmatchThreshold === 'number' ? opts.pixelmatchThreshold : screenshotBuildData.pixelmatchThreshold);
        return compareScreenshot(emulateConfig, screenshotBuildData, screenshotBuf, desc, testPath, pixelmatchThreshold);
    });
}
function createPuppeteerScreenshopOptions(opts) {
    const puppeteerOpts = {
        type: 'png',
        fullPage: opts.fullPage,
        omitBackground: opts.omitBackground,
        encoding: 'binary'
    };
    if (opts.clip) {
        puppeteerOpts.clip = {
            x: opts.clip.x,
            y: opts.clip.y,
            width: opts.clip.width,
            height: opts.clip.height
        };
    }
    return puppeteerOpts;
}

function newE2EPage(opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!global.__NEW_TEST_PAGE__) {
            throw new Error(`newE2EPage() is only available from E2E tests, and ran with the --e2e cmd line flag.`);
        }
        const page = yield global.__NEW_TEST_PAGE__();
        page._elements = [];
        page._goto = page.goto;
        yield setPageEmulate(page);
        yield page.setCacheEnabled(false);
        yield initPageEvents(page);
        initPageScreenshot(page);
        let docPromise = null;
        page.find = (selector) => __awaiter(this, void 0, void 0, function* () {
            if (!docPromise) {
                docPromise = page.evaluateHandle('document');
            }
            const documentJsHandle = yield docPromise;
            const docHandle = documentJsHandle.asElement();
            return find(page, docHandle, selector);
        });
        page.findAll = (selector) => __awaiter(this, void 0, void 0, function* () {
            if (!docPromise) {
                docPromise = page.evaluateHandle('document');
            }
            const documentJsHandle = yield docPromise;
            const docHandle = documentJsHandle.asElement();
            return findAll(page, docHandle, selector);
        });
        page.waitForChanges = waitForChanges.bind(null, page);
        page.on('console', consoleMessage);
        page.on('pageerror', pageError);
        page.on('requestfailed', requestFailed);
        if (typeof opts.html === 'string') {
            yield e2eSetContent(page, opts.html);
        }
        else if (typeof opts.url === 'string') {
            yield e2eGoTo(page, opts.url);
        }
        else {
            page.goto = e2eGoTo.bind(null, page);
            page.setContent = e2eSetContent.bind(null, page);
        }
        return page;
    });
}
function e2eGoTo(page, url) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (page.isClosed()) {
                console.error('e2eGoTo unavailable: page already closed');
                return;
            }
        }
        catch (e) {
            return;
        }
        if (typeof url !== 'string') {
            console.error('invalid gotoTest() url');
            yield closePage(page);
            return;
        }
        if (!url.startsWith('/')) {
            console.error('gotoTest() url must start with /');
            yield closePage(page);
            return;
        }
        const browserUrl = process.env.__STENCIL_BROWSER_URL__;
        if (typeof browserUrl !== 'string') {
            console.error('invalid gotoTest() browser url');
            yield closePage(page);
            return;
        }
        // resolves once the stencil app has finished loading
        const appLoaded = page.waitForFunction('window.stencilAppLoaded');
        const fullUrl = browserUrl + url.substring(1);
        let timedOut = false;
        try {
            yield page._goto(fullUrl, {
                waitUntil: 'load'
            });
            const tmr = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                timedOut = true;
                console.error(`App did not load in allowed time. Please ensure the url ${url} loads a stencil application.`);
                yield closePage(page);
            }), 4500);
            yield appLoaded;
            clearTimeout(tmr);
        }
        catch (e) {
            if (!timedOut) {
                console.error(`error goto: ${url}, ${e}`);
                yield closePage(page);
            }
        }
    });
}
function e2eSetContent(page, html) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (page.isClosed()) {
                console.error('e2eSetContent unavailable: page already closed');
                return;
            }
        }
        catch (e) {
            return;
        }
        if (typeof html !== 'string') {
            console.error('invalid e2eSetContent() html');
            yield closePage(page);
            return;
        }
        const loaderUrl = process.env.__STENCIL_LOADER_URL__;
        if (typeof loaderUrl !== 'string') {
            console.error('invalid e2eSetContent() loader script url');
            yield closePage(page);
            return;
        }
        const url = [
            `data:text/html;charset=UTF-8,`,
            `<script src="${loaderUrl}"></script>`,
            html
        ];
        try {
            // resolves once the stencil app has finished loading
            const appLoaded = page.waitForFunction('window.stencilAppLoaded');
            yield page._goto(url.join(''), {
                waitUntil: 'load'
            });
            yield appLoaded;
        }
        catch (e) {
            console.error(`e2eSetContent: ${e}`);
            yield closePage(page);
        }
    });
}
function setPageEmulate(page) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (page.isClosed()) {
                return;
            }
        }
        catch (e) {
            return;
        }
        const env = (process.env);
        const emulateJsonContent = env.__STENCIL_EMULATE__;
        if (!emulateJsonContent) {
            return;
        }
        try {
            const screenshotEmulate = JSON.parse(emulateJsonContent);
            const emulateOptions = {
                viewport: {
                    width: screenshotEmulate.width,
                    height: screenshotEmulate.height,
                    deviceScaleFactor: screenshotEmulate.deviceScaleFactor,
                    isMobile: screenshotEmulate.isMobile,
                    hasTouch: screenshotEmulate.hasTouch,
                    isLandscape: screenshotEmulate.isLandscape
                },
                userAgent: screenshotEmulate.userAgent
            };
            yield page.emulate(emulateOptions);
            if (screenshotEmulate.mediaType) {
                yield page.emulateMedia(screenshotEmulate.mediaType);
            }
        }
        catch (e) {
            console.error('setPageEmulate', e);
            yield closePage(page);
        }
    });
}
function waitForChanges(page) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (page.isClosed()) {
                return;
            }
        }
        catch (e) {
            return;
        }
        yield Promise.all(page._elements.map((elm) => __awaiter(this, void 0, void 0, function* () {
            yield elm.e2eRunActions();
        })));
        yield page.evaluate(() => {
            const promises = window['s-apps'].map((appNamespace) => {
                return window[appNamespace].onReady();
            });
            return Promise.all(promises);
        });
        yield Promise.all(page._elements.map((elm) => __awaiter(this, void 0, void 0, function* () {
            yield elm.e2eSync();
        })));
    });
}
function consoleMessage(c) {
    const type = c.type();
    if (typeof console[type] === 'function') {
        console[type](c.text());
    }
    else {
        console.log(type, c.text());
    }
}
function pageError(msg) {
    console.error('pageerror', msg);
}
function requestFailed(req) {
    console.error('requestfailed', req.url());
}

function setScreenshotEmulateData(userEmulateConfig, env) {
    return __awaiter(this, void 0, void 0, function* () {
        const screenshotEmulate = {
            width: 800,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: false,
            hasTouch: false,
            isLandscape: false
        };
        if (typeof userEmulateConfig.device === 'string') {
            try {
                const deviceDescriptors = require(env.__STENCIL_PUPPETEER_MODULE__ + '/DeviceDescriptors');
                const puppeteerEmulateOpts = deviceDescriptors[userEmulateConfig.device];
                if (!puppeteerEmulateOpts) {
                    console.error(`invalid emulate device: ${userEmulateConfig.device}`);
                    return;
                }
                screenshotEmulate.device = userEmulateConfig.device;
                screenshotEmulate.width = puppeteerEmulateOpts.viewport.width;
                screenshotEmulate.height = puppeteerEmulateOpts.viewport.height;
                screenshotEmulate.deviceScaleFactor = puppeteerEmulateOpts.viewport.deviceScaleFactor;
                screenshotEmulate.isMobile = puppeteerEmulateOpts.viewport.isMobile;
                screenshotEmulate.hasTouch = puppeteerEmulateOpts.viewport.hasTouch;
                screenshotEmulate.isLandscape = puppeteerEmulateOpts.viewport.isLandscape;
                screenshotEmulate.userAgent = puppeteerEmulateOpts.userAgent;
            }
            catch (e) {
                console.error('error loading puppeteer DeviceDescriptors', e);
                return;
            }
        }
        if (typeof userEmulateConfig.width === 'number') {
            screenshotEmulate.width = userEmulateConfig.width;
        }
        if (typeof userEmulateConfig.height === 'number') {
            screenshotEmulate.height = userEmulateConfig.height;
        }
        if (typeof userEmulateConfig.deviceScaleFactor === 'number') {
            screenshotEmulate.deviceScaleFactor = userEmulateConfig.deviceScaleFactor;
        }
        if (typeof userEmulateConfig.hasTouch === 'boolean') {
            screenshotEmulate.hasTouch = userEmulateConfig.hasTouch;
        }
        if (typeof userEmulateConfig.isLandscape === 'boolean') {
            screenshotEmulate.isLandscape = userEmulateConfig.isLandscape;
        }
        if (typeof userEmulateConfig.isMobile === 'boolean') {
            screenshotEmulate.isMobile = userEmulateConfig.isMobile;
        }
        if (typeof userEmulateConfig.userAgent === 'string') {
            screenshotEmulate.userAgent = userEmulateConfig.userAgent;
        }
        env.__STENCIL_EMULATE__ = JSON.stringify(screenshotEmulate);
    });
}

function runJest(config, env, jestConfigPath, doScreenshots) {
    return __awaiter(this, void 0, void 0, function* () {
        if (doScreenshots) {
            const emulateDevices = config.testing.emulate;
            if (Array.isArray(emulateDevices)) {
                return yield runJestScreenshot(config, env, jestConfigPath, emulateDevices);
            }
        }
        let passed = true;
        try {
            yield runJestDevice(config, jestConfigPath, null);
        }
        catch (e) {
            passed = false;
        }
        return passed;
    });
}
function runJestScreenshot(config, env, jestConfigPath, emulateDevices) {
    return __awaiter(this, void 0, void 0, function* () {
        config.logger.debug(`screenshot connector: ${config.testing.screenshotConnector}`);
        const ScreenshotConnector = require(config.testing.screenshotConnector);
        const connector = new ScreenshotConnector();
        const initTimespan = config.logger.createTimeSpan(`screenshot, initBuild started`, true);
        yield connector.initBuild({
            buildId: createBuildId(),
            buildMessage: createBuildMessage(),
            rootDir: config.rootDir,
            cacheDir: config.cacheDir,
            compareAppDir: path.join(config.sys.compiler.packageDir, 'screenshot', 'compare'),
            updateMaster: config.flags.updateScreenshot,
            logger: config.logger,
            allowableMismatchedPixels: config.testing.allowableMismatchedPixels,
            allowableMismatchedRatio: config.testing.allowableMismatchedRatio,
            pixelmatchThreshold: config.testing.pixelmatchThreshold
        });
        initTimespan.finish(`screenshot, initBuild finished`);
        env.__STENCIL_SCREENSHOT_BUILD__ = connector.toJson();
        const testsTimespan = config.logger.createTimeSpan(`screenshot, tests started`, true);
        let passed = true;
        for (let i = 0; i < emulateDevices.length; i++) {
            const emulate = emulateDevices[i];
            try {
                yield runJestDevice(config, jestConfigPath, emulate);
            }
            catch (e) {
                passed = false;
            }
        }
        testsTimespan.finish(`screenshot, tests finished`);
        const completeTimespan = config.logger.createTimeSpan(`screenshot, completeTimespan started`, true);
        yield connector.completeBuild();
        completeTimespan.finish(`screenshot, completeTimespan finished`);
        const publishTimespan = config.logger.createTimeSpan(`screenshot, publishBuild started`, true);
        yield connector.publishBuild();
        publishTimespan.finish(`screenshot, publishBuild finished`);
        config.logger.info(`screenshots images compared: ${connector.getTotalScreenshotImages()}`);
        config.logger.info(config.logger.magenta(connector.getComparisonSummaryUrl()));
        return passed;
    });
}
function runJestDevice(config, jestConfigPath, emulateDevice) {
    return __awaiter(this, void 0, void 0, function* () {
        const jestPkgJsonPath = config.sys.resolveModule(config.rootDir, 'jest');
        const jestPkgJson = require(jestPkgJsonPath);
        const jestBinModule = path.join(normalizePath(path.dirname(jestPkgJsonPath)), jestPkgJson.bin.jest);
        const args = [
            '--config', jestConfigPath,
            ...getJestArgs(config)
        ];
        if (config.watch) {
            args.push('--watch');
        }
        config.logger.debug(`jest module: ${jestBinModule}`);
        config.logger.debug(`jest args: ${args.join(' ')}`);
        return new Promise((resolve, reject) => {
            const jestProcessEnv = Object.assign({}, process.env);
            if (emulateDevice) {
                config.logger.info(`screenshot emulate: ${emulateDevice.device || emulateDevice.userAgent}`);
                setScreenshotEmulateData(emulateDevice, jestProcessEnv);
            }
            const p = cp.fork(jestBinModule, args, {
                cwd: config.testing.rootDir,
                env: jestProcessEnv
            });
            p.on(`unhandledRejection`, (r) => {
                reject(r);
            });
            p.once('exit', (d) => {
                if (d === 0) {
                    resolve();
                }
                else {
                    reject('tests failed');
                }
            });
            p.once('error', err => {
                reject(err.message);
            });
        });
    });
}
function createBuildId() {
    const d = new Date();
    let fmDt = (d.getFullYear() + '');
    fmDt += ('0' + (d.getMonth() + 1)).slice(-2);
    fmDt += ('0' + d.getDate()).slice(-2);
    fmDt += ('0' + d.getHours()).slice(-2);
    fmDt += ('0' + d.getMinutes()).slice(-2);
    fmDt += ('0' + d.getSeconds()).slice(-2);
    return fmDt;
}
function createBuildMessage() {
    const d = new Date();
    let fmDt = (d.getFullYear() + '') + '-';
    fmDt += ('0' + (d.getMonth() + 1)).slice(-2) + '-';
    fmDt += ('0' + d.getDate()).slice(-2) + ' ';
    fmDt += ('0' + d.getHours()).slice(-2) + ':';
    fmDt += ('0' + d.getMinutes()).slice(-2) + ':';
    fmDt += ('0' + d.getSeconds()).slice(-2);
    return `Local: ${fmDt}`;
}
function setupJestConfig(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const jestConfigPath = path.join(config.cacheDir, STENCIL_JEST_CONFIG);
        config.logger.debug(`jest config: ${jestConfigPath}`);
        const jestConfig = {};
        Object.keys(config.testing).forEach(testingConfig => {
            if (JEST_CONFIG.includes(testingConfig)) {
                jestConfig[testingConfig] = config.testing[testingConfig];
            }
        });
        if (typeof jestConfig.rootDir !== 'string') {
            jestConfig.rootDir = config.rootDir;
        }
        try {
            yield config.sys.fs.mkdir(config.cacheDir);
        }
        catch (e) { }
        yield config.sys.fs.writeFile(jestConfigPath, JSON.stringify(jestConfig, null, 2));
        return jestConfigPath;
    });
}
const JEST_CONFIG = [
    'automock',
    'bail',
    'browser',
    'cacheDirectory',
    'clearMocks',
    'collectCoverage',
    'collectCoverageFrom',
    'coverageDirectory',
    'coveragePathIgnorePatterns',
    'coverageReporters',
    'coverageThreshold',
    'errorOnDeprecated',
    'forceCoverageMatch',
    'globals',
    'globalSetup',
    'globalTeardown',
    'moduleDirectories',
    'moduleFileExtensions',
    'moduleNameMapper',
    'modulePathIgnorePatterns',
    'modulePaths',
    'notify',
    'notifyMode',
    'preset',
    'prettierPath',
    'projects',
    'reporters',
    'resetMocks',
    'resetModules',
    'resolver',
    'restoreMocks',
    'rootDir',
    'roots',
    'runner',
    'setupFiles',
    'setupTestFrameworkScriptFile',
    'snapshotSerializers',
    'testEnvironment',
    'testEnvironmentOptions',
    'testMatch',
    'testPathIgnorePatterns',
    'testRegex',
    'testResultsProcessor',
    'testRunner',
    'testURL',
    'timers',
    'transform',
    'transformIgnorePatterns',
    'unmockedModulePathPatterns',
    'verbose',
    'watchPathIgnorePatterns',
];
const STENCIL_JEST_CONFIG = 'stencil.jest.config.json';
function getJestArgs(config) {
    const args = [];
    if (config.flags && config.flags.args) {
        config.flags.args.forEach(arg => {
            if (JEST_ARGS.includes(arg)) {
                args.push(arg);
            }
            else if (JEST_ARGS.some(jestArg => arg.startsWith(jestArg))) {
                args.push(arg);
            }
        });
    }
    if (config.logger.level === 'debug') {
        if (!args.includes('--detectOpenHandles')) {
            args.push('--detectOpenHandles');
        }
    }
    return args;
}
const JEST_ARGS = [
    '--bail',
    '--cache',
    '--changedFilesWithAncestor',
    '--changedSince',
    '--clearCache',
    '--collectCoverageFrom=',
    '--colors',
    '--config=',
    '--coverage',
    '--debug',
    '--detectOpenHandles',
    '--env=',
    '--errorOnDeprecated',
    '--expand',
    '--findRelatedTests',
    '--forceExit',
    '--help',
    '--init',
    '--json',
    '--outputFile=',
    '--lastCommit',
    '--listTests',
    '--logHeapUsage',
    '--maxWorkers=',
    '--noStackTrace',
    '--notify',
    '--onlyChanged',
    '--passWithNoTests',
    '--reporters',
    '--runInBand',
    '--setupTestFrameworkScriptFile=',
    '--showConfig',
    '--silent',
    '--testNamePattern=',
    '--testLocationInResults',
    '--testPathPattern=',
    '--testRunner=',
    '--updateSnapshot',
    '--useStderr',
    '--verbose',
    '--version',
    '--watch',
    '--watchAll',
    '--watchman',
];

class Testing {
    constructor(config) {
        this.isValid = false;
        const { Compiler } = require('../compiler/index.js');
        this.compiler = new Compiler(setupTestingConfig(config));
        this.config = this.compiler.config;
        this.isValid = this.compiler.isValid;
        if (this.isValid) {
            if (!config.flags.spec && !config.flags.e2e) {
                config.logger.error(`Testing requires either the --spec or --e2e command line flags, or both. For example, to run unit tests, use the command: stencil test --spec`);
                this.isValid = false;
            }
        }
    }
    runTests() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isValid || !this.compiler) {
                return false;
            }
            const env = process.env;
            const compiler = this.compiler;
            const config = this.config;
            const { isValid, outputTarget } = getOutputTarget(config);
            if (!isValid) {
                this.isValid = false;
                return false;
            }
            const msg = [];
            if (config.flags.e2e) {
                msg.push('e2e');
                env.__STENCIL_E2E_TESTS__ = 'true';
            }
            if (config.flags.spec) {
                msg.push('spec');
            }
            config.logger.info(config.logger.magenta(`testing ${msg.join(' and ')} files`));
            const doScreenshots = !!(config.flags.e2e && config.flags.screenshot);
            if (doScreenshots) {
                env.__STENCIL_SCREENSHOT__ = 'true';
                if (config.flags.updateScreenshot) {
                    config.logger.info(config.logger.magenta(`updating master screenshots`));
                }
                else {
                    config.logger.info(config.logger.magenta(`comparing against master screenshots`));
                }
            }
            const jestEnvNodeModule = config.sys.lazyRequire.getModulePath('jest-environment-node');
            env.__STENCIL_JEST_ENVIRONMENT_NODE_MODULE__ = jestEnvNodeModule;
            config.logger.debug(`jest-environment-node: ${jestEnvNodeModule}`);
            if (config.flags.e2e) {
                // e2e tests only
                // do a build, start a dev server
                // and spin up a puppeteer browser
                let buildTask = null;
                const doBuild = !(config.flags && config.flags.build === false);
                if (doBuild) {
                    buildTask = compiler.build();
                }
                const startupResults = yield Promise.all([
                    compiler.startDevServer(),
                    startPuppeteerBrowser(config),
                ]);
                this.devServer = startupResults[0];
                this.puppeteerBrowser = startupResults[1];
                if (doBuild) {
                    const results = yield buildTask;
                    if (!results || (!config.watch && hasError(results && results.diagnostics))) {
                        yield this.destroy();
                        return false;
                    }
                }
                if (this.devServer) {
                    env.__STENCIL_BROWSER_URL__ = this.devServer.browserUrl;
                    config.logger.debug(`dev server url: ${env.__STENCIL_BROWSER_URL__}`);
                    env.__STENCIL_LOADER_URL__ = getLoaderScriptUrl(config, outputTarget, this.devServer.browserUrl);
                    config.logger.debug(`dev server loader: ${env.__STENCIL_LOADER_URL__}`);
                }
            }
            this.jestConfigPath = yield setupJestConfig(config);
            const passed = yield runJest(config, env, this.jestConfigPath, doScreenshots);
            config.logger.info('');
            return passed;
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config) {
                if (this.jestConfigPath) {
                    try {
                        yield this.config.sys.fs.unlink(this.jestConfigPath);
                    }
                    catch (e) { }
                }
                this.config.sys.destroy();
                this.config = null;
            }
            if (this.devServer) {
                yield this.devServer.close();
                this.devServer = null;
            }
            if (this.puppeteerBrowser) {
                yield this.puppeteerBrowser.close();
                this.puppeteerBrowser = null;
            }
            this.compiler = null;
        });
    }
}
function setupTestingConfig(config) {
    config.buildEs5 = false;
    config.devMode = true;
    config.maxConcurrentWorkers = 1;
    config.validateTypes = false;
    config.flags = config.flags || {};
    config.flags.serve = false;
    config.flags.open = false;
    return config;
}
function getOutputTarget(config) {
    let isValid = true;
    let outputTarget = config.outputTargets.find(o => o.type === 'www');
    if (!outputTarget) {
        outputTarget = config.outputTargets.find(o => o.type === 'dist');
        if (!outputTarget) {
            config.logger.error(`Test missing config output target`);
            isValid = false;
        }
    }
    outputTarget.serviceWorker = null;
    config.outputTargets = [outputTarget];
    return { isValid, outputTarget };
}
function getLoaderScriptUrl(config, outputTarget, browserUrl) {
    const appLoaderFilePath = getLoaderPath(config, outputTarget);
    let appLoadUrlPath;
    if (outputTarget.type === 'www') {
        appLoadUrlPath = config.sys.path.relative(outputTarget.dir, appLoaderFilePath);
    }
    else {
        appLoadUrlPath = config.sys.path.relative(config.rootDir, appLoaderFilePath);
    }
    return browserUrl + appLoadUrlPath;
}

exports.createJestPuppeteerEnvironment = createJestPuppeteerEnvironment;
exports.h = h;
exports.jestPreprocessor = jestPreprocessor;
exports.jestSetupTestFramework = jestSetupTestFramework;
exports.newE2EPage = newE2EPage;
exports.Testing = Testing;
exports.transpile = transpile;
