'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var url = require('url');

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function fileExists(filePath) {
    return new Promise(resolve => {
        fs.access(filePath, (err) => resolve(!err));
    });
}
function readFile(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, 'utf-8', (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
function readFileBuffer(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
function writeFile(filePath, data) {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, data, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
function mkDir(filePath) {
    return new Promise(resolve => {
        fs.mkdir(filePath, () => {
            resolve();
        });
    });
}
function emptyDir(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield readDir(dir);
        const promises = files.map((fileName) => __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(dir, fileName);
            const isDirFile = yield isFile(filePath);
            if (isDirFile) {
                yield unlink(filePath);
            }
        }));
        yield Promise.all(promises);
    });
}
function readDir(dir) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            fs.readdir(dir, (err, files) => {
                if (err) {
                    resolve([]);
                }
                else {
                    resolve(files);
                }
            });
        });
    });
}
function isFile(itemPath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            fs.stat(itemPath, (err, stat) => {
                if (err) {
                    resolve(false);
                }
                else {
                    resolve(stat.isFile());
                }
            });
        });
    });
}
function unlink(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => {
            fs.unlink(filePath, () => {
                resolve();
            });
        });
    });
}

/**
 * SSR Attribute Names
 */

function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, '/');
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === '/') {
        const colonIndex = str.indexOf(':');
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ScreenshotConnector {
    constructor() {
        this.screenshotDirName = 'screenshot';
        this.masterDirName = 'master';
        this.localDirName = 'local';
        this.compareAppFileName = 'compare.html';
        this.imagesDirName = 'images';
    }
    initBuild(opts) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = opts.logger;
            this.buildId = opts.buildId;
            this.buildMessage = opts.buildMessage;
            this.cacheDir = opts.cacheDir;
            this.rootDir = opts.rootDir;
            this.compareAppDir = opts.compareAppDir;
            this.updateMaster = !!opts.updateMaster;
            this.allowableMismatchedPixels = opts.allowableMismatchedPixels;
            this.allowableMismatchedRatio = opts.allowableMismatchedRatio;
            this.pixelmatchThreshold = opts.pixelmatchThreshold;
            this.logger.debug(`screenshot build: ${this.buildId}, ${this.buildMessage}, updateMaster: ${this.updateMaster}`);
            this.logger.debug(`screenshot, allowableMismatchedPixels: ${this.allowableMismatchedPixels}, allowableMismatchedRatio: ${this.allowableMismatchedRatio}, pixelmatchThreshold: ${this.pixelmatchThreshold}`);
            if (typeof opts.screenshotDirName === 'string') {
                this.screenshotDirName = opts.screenshotDirName;
            }
            if (typeof opts.masterDirName === 'string') {
                this.masterDirName = opts.masterDirName;
            }
            if (typeof opts.localDirName === 'string') {
                this.localDirName = opts.localDirName;
            }
            if (typeof opts.compareAppFileName === 'string') {
                this.compareAppFileName = opts.compareAppFileName;
            }
            if (typeof opts.imagesDirName === 'string') {
                this.imagesDirName = opts.imagesDirName;
            }
            this.screenshotDir = path.join(this.rootDir, this.screenshotDirName);
            this.imagesDir = path.join(this.screenshotDir, this.imagesDirName);
            this.masterDir = path.join(this.screenshotDir, this.masterDirName);
            this.localDir = path.join(this.screenshotDir, this.localDirName);
            this.logger.debug(`screenshotDirPath: ${this.screenshotDir}`);
            this.logger.debug(`imagesDirPath: ${this.imagesDir}`);
            this.logger.debug(`masterDirPath: ${this.masterDir}`);
            this.logger.debug(`localDirPath: ${this.localDir}`);
            yield mkDir(this.screenshotDir);
            yield Promise.all([
                mkDir(this.imagesDir),
                mkDir(this.masterDir),
                mkDir(this.localDir)
            ]);
            const fsTasks = [];
            if (this.updateMaster) {
                this.logger.debug(`empty master: ${this.masterDir}`);
                fsTasks.push(emptyDir(this.masterDir));
            }
            else {
                yield this.pullMasterImages();
            }
            fsTasks.push(emptyDir(this.localDir));
            const gitIgnorePath = path.join(this.screenshotDir, '.gitignore');
            const gitIgnoreExists = yield fileExists(gitIgnorePath);
            if (!gitIgnoreExists) {
                const content = [];
                if (opts.gitIgnoreImages !== false) {
                    content.push(this.imagesDirName);
                }
                if (opts.gitIgnoreLocal !== false) {
                    content.push(this.localDirName);
                }
                if (opts.gitIgnoreCompareApp !== false) {
                    content.push(this.compareAppFileName);
                }
                if (content.length) {
                    content.unshift(`# only master screenshot data should be committed`);
                    fsTasks.push(writeFile(gitIgnorePath, content.join('\n')));
                }
            }
            const compareAppFilePath = path.join(this.screenshotDir, this.compareAppFileName);
            const url$$1 = new url.URL(`file://${compareAppFilePath}`);
            this.compareUrl = url$$1.href;
            this.logger.debug(`compareUrl: ${this.compareUrl}`);
            yield Promise.all(fsTasks);
        });
    }
    pullMasterImages() {
        return __awaiter$1(this, void 0, void 0, function* () { });
    }
    completeBuild() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const masterFilePaths = (yield readDir(this.masterDir)).map(f => path.join(this.masterDir, f)).filter(f => f.endsWith('.json'));
            const masterScreenshots = yield Promise.all(masterFilePaths.map((f) => __awaiter$1(this, void 0, void 0, function* () { return JSON.parse(yield readFile(f)); })));
            sortScreenshots(masterScreenshots);
            this.masterBuild = {
                id: 'master',
                message: 'Master',
                screenshots: masterScreenshots
            };
            const localFilePaths = (yield readDir(this.localDir)).map(f => path.join(this.localDir, f)).filter(f => f.endsWith('.json'));
            const localScreenshots = yield Promise.all(localFilePaths.map((f) => __awaiter$1(this, void 0, void 0, function* () { return JSON.parse(yield readFile(f)); })));
            sortScreenshots(localScreenshots);
            this.localBuild = {
                id: this.buildId,
                message: this.buildMessage,
                screenshots: localScreenshots
            };
            yield emptyDir(this.localDir);
            const localBuildPath = path.join(this.localDir, `${this.localBuild.id}.json`);
            yield writeFile(localBuildPath, JSON.stringify(this.localBuild, null, 2));
            for (let i = 0; i < localScreenshots.length; i++) {
                const screenshot = localScreenshots[i];
                const imageName = screenshot.image;
                const jsonpFileName = `screenshot_${imageName}.js`;
                const jsonFilePath = path.join(this.cacheDir, jsonpFileName);
                const jsonpExists = yield fileExists(jsonFilePath);
                if (jsonpExists) {
                    continue;
                }
                const imageFilePath = path.join(this.imagesDir, imageName);
                const imageBuf = yield readFileBuffer(imageFilePath);
                const jsonpContent = `loadScreenshot("${imageName}","data:image/png;base64,${imageBuf.toString('base64')}",${screenshot.width},${screenshot.height},${screenshot.deviceScaleFactor},${screenshot.naturalWidth},${screenshot.naturalHeight});`;
                yield writeFile(jsonFilePath, jsonpContent);
            }
        });
    }
    publishBuild() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const appUrl = normalizePath(path.relative(this.screenshotDir, this.compareAppDir));
            const imagesUrl = normalizePath(path.relative(this.screenshotDir, this.imagesDir));
            const jsonpUrl = normalizePath(path.relative(this.screenshotDir, this.cacheDir));
            const html = createLocalCompare(appUrl, imagesUrl, jsonpUrl, this.masterBuild, this.localBuild);
            const compareAppPath = path.join(this.screenshotDir, this.compareAppFileName);
            yield writeFile(compareAppPath, html);
        });
    }
    getComparisonSummaryUrl() {
        return this.compareUrl;
    }
    getTotalScreenshotImages() {
        return this.localBuild.screenshots.length;
    }
    toJson() {
        const screenshotBuild = {
            id: this.buildId,
            rootDir: this.rootDir,
            cacheDir: this.cacheDir,
            screenshotDirPath: this.screenshotDir,
            imagesDirPath: this.imagesDir,
            masterDirPath: this.masterDir,
            localDirPath: this.localDir,
            updateMaster: this.updateMaster,
            compareUrlTemplate: this.compareUrl,
            allowableMismatchedPixels: this.allowableMismatchedPixels,
            allowableMismatchedRatio: this.allowableMismatchedRatio,
            pixelmatchThreshold: this.pixelmatchThreshold
        };
        return JSON.stringify(screenshotBuild);
    }
}
function createLocalCompare(appUrl, imagesUrl, jsonpUrl, masterBuild, localBuild) {
    return `<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
  <meta charset="utf-8">
  <title>Stencil Screenshot Comparison</title>
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="x-ua-compatible" content="IE=Edge">
  <link href="${appUrl}/build/app.css" rel="stylesheet">
  <script src="${appUrl}/build/app.js"></script>
  <link rel="icon" type="image/x-icon" href="${appUrl}/assets/favicon.ico">
</head>
<body>
  <ion-app></ion-app>
  <script>
    (function() {
      var compare = document.createElement('local-compare');
      compare.imagesUrl = '${imagesUrl}/';
      compare.jsonpUrl = '${jsonpUrl}/';
      compare.buildA = ${JSON.stringify(masterBuild)};
      compare.buildB = ${JSON.stringify(localBuild)};
      compare.className = 'ion-page';
      document.querySelector('ion-app').appendChild(compare);
    })();
  </script>
</body>
</html>`;
}
function sortScreenshots(screenshots) {
    screenshots.sort((a, b) => {
        if (a.desc && b.desc) {
            if (a.desc.toLowerCase() < b.desc.toLowerCase())
                return -1;
            if (a.desc.toLowerCase() > b.desc.toLowerCase())
                return 1;
        }
        if (a.device && b.device) {
            if (a.device.toLowerCase() < b.device.toLowerCase())
                return -1;
            if (a.device.toLowerCase() > b.device.toLowerCase())
                return 1;
        }
        if (a.userAgent && b.userAgent) {
            if (a.userAgent.toLowerCase() < b.userAgent.toLowerCase())
                return -1;
            if (a.userAgent.toLowerCase() > b.userAgent.toLowerCase())
                return 1;
        }
        if (a.width < b.width)
            return -1;
        if (a.width > b.width)
            return 1;
        if (a.height < b.height)
            return -1;
        if (a.height > b.height)
            return 1;
        if (a.id < b.id)
            return -1;
        if (a.id > b.id)
            return 1;
        return 0;
    });
}

exports.ScreenshotConnector = ScreenshotConnector;
